<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Jul 30 18:25:33 EDT 1999 -->
<TITLE>
: Class  ZTransform
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" ID="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" ID="NavBarCell1Rev"> &nbsp;<FONT ID="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZVisualComponent.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ZTransform.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
edu.umd.cs.jazz.scenegraph</FONT>
<BR>
Class  ZTransform</H2>
<PRE>
java.lang.Object
  |
  +--<B>edu.umd.cs.jazz.scenegraph.ZTransform</B>
</PRE>
<HR>
<DL>
<DT>public class <B>ZTransform</B><DT>extends java.lang.Object<DT>implements <A HREF="../../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A>, java.lang.Cloneable</DL>

<P>
ZTransform provides the capabilities of the AffineTransform plus some extra manipulators
 on the transform.  ZTransform is also aware of the fact that it is a composite part of
 a scenegraph object and notifies the associated object via a damage call whenever the 
 transform changes state.  A ZTransform is not obligated to have a parent object.
 <p>
 Where Operation is one of (translate, scale, or rotate) ZTransform provides the following matrix
 of manipulators (the methods with mils as an arg will animate to the final state):
 <pre>
 operation(args)		operationTo(args)
 operation(args, mils)        operationTo(args, mils)
 </pre>
 ZTransform also provides a getOperation for each Operation that returns the relevant portion of
 of the transform.
 <p>
 In order to use ZTransform effectively, it is important to have a solid understanding
 of affine transforms, matrix multiplication, and the standard use of matrices for
 graphics coordinate systems.  The best place to start is by reading the documentation
 on <CODE>AffineTransform</CODE>.  After that, a good next bit is to read
 a standard 3D graphics text such as "Interactive Computer Graphics: a Top-Down Approach
 with OpenGL" 2nd Edition by Angel (Addison-Wesley), or "Computer Graphics: Principles
 and Practice, Second Edition in C" by Foley, van Dam, Feiner, Hughes, and Phillips
 (Addison-Wesley).
 <p>
 Here is a very short lesson on matrices and graphics.  An 2D affine transform is typically
 represented by a 3x3 matrix which we typically call M, and sometimes denote [M].  An
 affine transform can represent any 2D translation, scale, rotation, shear or any combination
 of these 4 operators.  Matrices which are pure translations, scales, and rotations are
 typically denoted T, S, or R ([T], [S], or [R]), respectively.  The identity matrix
 is typically denoted I or [I].
 <p>
 The reason these transforms are so powerful is because they can be combined in a
 semantically straightforward way by simply concatenating the matrices.  Creating
 a ZTransform creates I.  Calling one of the transformation methods on a transform is exactly equivalent to
 concatenating the transform with a new transform that specifies the transformation.
 Thus, transform.translate(dx, dy) is equivalent to [M][T] where M represents the original
 transform, and T represents the translation matrix of dx, dy.  Similarly, transform.scale(ds)
 is equivalent to [M][S].  And, these build up, so
 <pre>
    ZTransform t = new ZTransform();
    t.scale(ds);
    t.translate(dx, dy);
    t.rotate(Math.PI * 0.5f);
 </pre>
 is equivalent to these four matrices concatenated together with standard
 matrix multiplication [I][S][T][R]
 <p>
 However, a crucial place for confusion with these transforms is that the transforms
 get applied in the <em>reverse</em> order of how you placed the calls to the transforms
 in your code.  To understand this, you must realize that the object paint methods
 get called <em>after</em> the transformations are applied.  Your paint methods specify
 geometry (such as points) which get transformed by the current transformation before
 being painted.  For a simple example, think of a point P.  Well, the point 
 post-multiplies the current transformation.  In the example above, that works out
 to a new point P' being computed as P' = [S][T][R]P.  You can think about this
 as the original point P first getting multiplied (on the left) by R, then the result
 gets multipled (on the left) by T, and that gets multiplied (on the left) by S.
 <p>
 Let's go through a simple example with actual numbers.  Suppose you want to take a
 rectangle at (0, 0) with width 50 and height 50, and first translate it 50 units to the right, 
 and then scale the whole thing by 2 about the origin.  
 The result should be that the rectangle actually gets rendered at (100, 0) with dimensions
 of (100x100).  The following code in Jazz implements this example.
 <pre>
    ZRectangle rect = new ZRectangle(0, 0, 50, 50);
    ZNode node = new ZNode(rect);
    drawingLayer.addChild(node);

				// Note how we call scale first even though
				// the translation will actually be applied before the scale.
    node.getTransform().scale(2);
    node.getTransform().translate(50, 0);
 </pre>
 <p>
 Sometimes it is useful to transform an object in global coordinates - even though
 that object has a transform of its own.  For instance, suppose you are implementing an
 event handler for selection, and want to move an object so that it follows the pointer.
 In order to do this, you need to translate the object in <em>global</em> coordinates.
 Since the node you want to move may have a transform already (for instance, it may be scaled), 
 if you simply translate the object, that transform will be applied <em>after</em> the
 scale, and thus the translation will be modified by the scale.  That is, the object
 may have the matrix [M].  Calling translate will generate [M][T].  If M represents a scale of 2,
 then the translation will actually translate twice as much as you intended.  
 <p>
 The solution
 is to <em>pre-concatenate</em> the translation so you end up with [T][M].  With ZTransform,
 you can preconcatenate an affine transform onto the current transform.  So, the
 code for this translation problem would like:
 <pre>
    AffineTransform tx = AffineTransform.getTranslateInstance(dx, dy);
    node.getTransform().preConcatenate(tx);
 </pre>
<P>
<DL>
<DT><B>See Also: </B><DD><CODE>AffineTransform</CODE></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZScenegraphObject.html">ZScenegraphObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#parent">parent</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.awt.geom.AffineTransform</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform">transform</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#ZTransform()">ZTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an ZTransform based on an identity AffineTransform</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#ZTransform(java.awt.geom.AffineTransform)">ZTransform</A></B>(java.awt.geom.AffineTransform&nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an ZTransform based on AffineTransform parameter</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#ZTransform(edu.umd.cs.jazz.scenegraph.ZTransform)">ZTransform</A></B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html">ZTransform</A>&nbsp;xf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new ZTransform that is a copy of the specified ZTransform (i.e., a "copy constructor").</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#animate(java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.scenegraph.ZSurface)">animate</A></B>(java.awt.geom.AffineTransform&nbsp;tx,
        int&nbsp;millis,
        <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transform of this object to the specified transform, 
 and animate the change from its current transformation over the specified
 number of milliseconds using a slow-in slow-out animation.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#animate(java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.scenegraph.ZSurface, edu.umd.cs.jazz.util.ZLerp)">animate</A></B>(java.awt.geom.AffineTransform&nbsp;tx,
        int&nbsp;millis,
        <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface,
        <A HREF="../../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transform of this object to the specified transform, 
 and animate the change from its current transformation over the specified
 number of milliseconds.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#animate(edu.umd.cs.jazz.scenegraph.ZNode[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.scenegraph.ZSurface)">animate</A></B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZNode.html">ZNode</A>[]&nbsp;nodes,
        java.awt.geom.AffineTransform[]&nbsp;txs,
        int&nbsp;millis,
        <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transforms of the specified array of nodes to the specified
 array of transforms,
 and animate the change over the specified
 number of milliseconds using a slow-in slow-out animation.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#animate(edu.umd.cs.jazz.scenegraph.ZNode[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.scenegraph.ZSurface, edu.umd.cs.jazz.util.ZLerp)">animate</A></B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZNode.html">ZNode</A>[]&nbsp;nodes,
        java.awt.geom.AffineTransform[]&nbsp;txs,
        int&nbsp;millis,
        <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface,
        <A HREF="../../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transforms of the specified array of nodes to the specified
 array of transforms, and animate the change over the specified
 number of milliseconds.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duplicates the current ZTransform by using the copy constructor.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#concatenate(java.awt.geom.AffineTransform)">concatenate</A></B>(java.awt.geom.AffineTransform&nbsp;tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates an <code>AffineTransform</code> <code>tx</code> to
 this <code>AffineTransform</code> Cx in the most commonly useful
 way to provide a new user space
 that is mapped to the former user space by <code>Tx</code>.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html">ZTransform</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#createInverse()">createInverse</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create inverse ZTransform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.AffineTransform</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#createInverseAffineTransform()">createInverseAffineTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create inverse affine transform stored in the ZTransform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.AffineTransform</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#getAffineTransform()">getAffineTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get copy of affine transform stored in the ZTransform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#getMatrix(double[])">getMatrix</A></B>(double[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the 6 specifiable values in the 3x3 affine transformation
 matrix that this ZTransform wraps,
 and places them into an array of double precisions values.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZScenegraphObject.html">ZScenegraphObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#getParent()">getParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#getRotation()">getRotation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current rotation (Z-axis) of this object
 Not currently immplemented BDMREV</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#getScale()">getScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current scale of this transform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.Point2D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#getTranslation()">getTranslation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current translation of this object</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#getType()">getType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the type of transform as specified by AffineTransform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#inverseTransform(java.awt.geom.Area)">inverseTransform</A></B>(java.awt.geom.Area&nbsp;area)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)">inverseTransform</A></B>(java.awt.geom.Point2D&nbsp;srcPt,
                 java.awt.geom.Point2D&nbsp;destPt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#inverseTransform(java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D)">inverseTransform</A></B>(java.awt.geom.Rectangle2D&nbsp;srcRect,
                 java.awt.geom.Rectangle2D&nbsp;destRect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#position(java.awt.geom.Point2D, java.awt.geom.Point2D, java.awt.geom.Rectangle2D, int, edu.umd.cs.jazz.scenegraph.ZSurface)">position</A></B>(java.awt.geom.Point2D&nbsp;srcPt,
         java.awt.geom.Point2D&nbsp;destPt,
         java.awt.geom.Rectangle2D&nbsp;destBounds,
         int&nbsp;millis,
         <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This will calculate the necessary transform in order to make this
 transform's corresponding node appear at a particular position relative to the
 specified bounding box.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#position(java.awt.geom.Point2D, java.awt.geom.Point2D, edu.umd.cs.jazz.scenegraph.ZNode, int, edu.umd.cs.jazz.scenegraph.ZSurface)">position</A></B>(java.awt.geom.Point2D&nbsp;srcPt,
         java.awt.geom.Point2D&nbsp;destPt,
         <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZNode.html">ZNode</A>&nbsp;refNode,
         int&nbsp;millis,
         <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This will calculate the necessary transform in order to make this
 transform's corresponding node appear at a particular position relative to the
 specified node.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#preConcatenate(java.awt.geom.AffineTransform)">preConcatenate</A></B>(java.awt.geom.AffineTransform&nbsp;tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates an <code>AffineTransform</code> <code>Tx</code> to
 this <code>AffineTransform</code> Cx
 in a less commonly used way such that <code>Tx</code> modifies the
 coordinate transformation relative to the absolute pixel
 space rather than relative to the existing user space.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#rotate(float)">rotate</A></B>(float&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the object by the specified amount</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#rotate(float, float, float)">rotate</A></B>(float&nbsp;theta,
       float&nbsp;xctr,
       float&nbsp;yctr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the object by the specified amount around the specified anchor point</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#rotate(float, float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">rotate</A></B>(float&nbsp;theta,
       float&nbsp;xctr,
       float&nbsp;yctr,
       int&nbsp;millis,
       <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the object, via animation, theta radians about the specified anchor point</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#rotate(float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">rotate</A></B>(float&nbsp;theta,
       int&nbsp;millis,
       <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the object, via animation, theta radians</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scale(float)">scale</A></B>(float&nbsp;dz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale the object from its current scale to the scale specified
 by muliplying the current scale and dz.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scale(float, float, float)">scale</A></B>(float&nbsp;dz,
      float&nbsp;x,
      float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale the object around the specified point (x, y) 
 from its current scale to the scale specified
 by muliplying the current scale and dz.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scale(float, float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">scale</A></B>(float&nbsp;dz,
      float&nbsp;x,
      float&nbsp;y,
      int&nbsp;millis,
      <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the object around the specified point (x, y)
 from its current scale to the scale specified
 by muliplying the current scale and dz</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scale(float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">scale</A></B>(float&nbsp;dz,
      int&nbsp;millis,
      <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the object from its current scale to the scale specified
 by muliplying the current scale and deltaZ</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scaleTo(float)">scaleTo</A></B>(float&nbsp;finalz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the scale of the object to the specified target scale.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scaleTo(float, float, float)">scaleTo</A></B>(float&nbsp;finalz,
        float&nbsp;x,
        float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the scale of the object to the specified target scale,
 scaling the object around the specified point (x, y).</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scaleTo(float, float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">scaleTo</A></B>(float&nbsp;finalz,
        float&nbsp;x,
        float&nbsp;y,
        int&nbsp;millis,
        <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the object around the specified point (x, y)
 to the specified target scale.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#scaleTo(float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">scaleTo</A></B>(float&nbsp;finalz,
        int&nbsp;millis,
        <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the object from its current scale to the specified target scale.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#setAffineTransform(java.awt.geom.AffineTransform)">setAffineTransform</A></B>(java.awt.geom.AffineTransform&nbsp;tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the underlying affine transform that this ZTransform wraps.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#setAffineTransform(double, double, double, double, double, double)">setAffineTransform</A></B>(double&nbsp;m00,
                   double&nbsp;m10,
                   double&nbsp;m01,
                   double&nbsp;m11,
                   double&nbsp;m02,
                   double&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the underlying affine transform that this ZTransform wraps.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#setParent(edu.umd.cs.jazz.scenegraph.ZScenegraphObject)">setParent</A></B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZScenegraphObject.html">ZScenegraphObject</A>&nbsp;aParent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#setState(java.lang.String, java.lang.String, java.lang.Object)">setState</A></B>(java.lang.String&nbsp;fieldType,
         java.lang.String&nbsp;fieldName,
         java.lang.Object&nbsp;fieldValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set some state of this object as it gets read back in.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a string that represents this object for debugging.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform(double[], int, double[], int, int)">transform</A></B>(double[]&nbsp;srcPts,
          int&nbsp;srcOff,
          double[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms an array of double precision coordinates by this transform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform(double[], int, float[], int, int)">transform</A></B>(double[]&nbsp;srcPts,
          int&nbsp;srcOff,
          float[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms an array of double precision coordinates by this transform
 and stores the results into an array of floats.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform(float[], int, double[], int, int)">transform</A></B>(float[]&nbsp;srcPts,
          int&nbsp;srcOff,
          double[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms an array of floating point coordinates by this transform
 and stores the results into an array of doubles.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform(float[], int, float[], int, int)">transform</A></B>(float[]&nbsp;srcPts,
          int&nbsp;srcOff,
          float[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms an array of floating point coordinates by this transform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform(java.awt.geom.Point2D[], int, java.awt.geom.Point2D[], int, int)">transform</A></B>(java.awt.geom.Point2D[]&nbsp;ptSrc,
          int&nbsp;srcOff,
          java.awt.geom.Point2D[]&nbsp;ptDst,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms an array of point objects by this transform.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.Point2D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform(java.awt.geom.Point2D, java.awt.geom.Point2D)">transform</A></B>(java.awt.geom.Point2D&nbsp;ptSrc,
          java.awt.geom.Point2D&nbsp;ptDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms the specified <code>ptSrc</code> and stores the result
 in <code>ptDst</code>.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.Rectangle2D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#transform(java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D)">transform</A></B>(java.awt.geom.Rectangle2D&nbsp;rectSrc,
          java.awt.geom.Rectangle2D&nbsp;rectDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms the specified <code>rectSrc</code> and stores the result
 in <code>rectDst</code>.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#translate(float, float)">translate</A></B>(float&nbsp;dx,
          float&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translate the object by the specified deltaX and deltaY</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#translate(float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">translate</A></B>(float&nbsp;dx,
          float&nbsp;dy,
          int&nbsp;millis,
          <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the object from its current position by the specified deltaX and deltaY</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#translateTo(float, float)">translateTo</A></B>(float&nbsp;x,
            float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translate the object to the specified position</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#translateTo(float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)">translateTo</A></B>(float&nbsp;x,
            float&nbsp;y,
            int&nbsp;millis,
            <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the object from its current position to the positino specified
 by x, y</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#writeObject(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObject</A></B>(<A HREF="../../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write out all of this object's state.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#writeObjectRecurse(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObjectRecurse</A></B>(<A HREF="../../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify which objects this object references in order to write out the scenegraph properly</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" ID="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE>equals, 
finalize, 
getClass, 
hashCode, 
notify, 
notifyAll, 
wait, 
wait, 
wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="transform"><!-- --></A><H3>
transform</H3>
<PRE>
protected java.awt.geom.AffineTransform <B>transform</B></PRE>
<DL>
</DL>
<HR>

<A NAME="parent"><!-- --></A><H3>
parent</H3>
<PRE>
protected <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZScenegraphObject.html">ZScenegraphObject</A> <B>parent</B></PRE>
<DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ZTransform()"><!-- --></A><H3>
ZTransform</H3>
<PRE>
public <B>ZTransform</B>()</PRE>
<DL>
<DD>Create an ZTransform based on an identity AffineTransform</DL>
<HR>

<A NAME="ZTransform(java.awt.geom.AffineTransform)"><!-- --></A><H3>
ZTransform</H3>
<PRE>
public <B>ZTransform</B>(java.awt.geom.AffineTransform&nbsp;at)</PRE>
<DL>
<DD>Create an ZTransform based on AffineTransform parameter<DD><DL>
<DT><B>Parameters:</B><DD><CODE><code>at</code></CODE> - &nbsp;</DL>
</DD>
</DL>
<HR>

<A NAME="ZTransform(edu.umd.cs.jazz.scenegraph.ZTransform)"><!-- --></A><H3>
ZTransform</H3>
<PRE>
public <B>ZTransform</B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html">ZTransform</A>&nbsp;xf)</PRE>
<DL>
<DD>Constructs a new ZTransform that is a copy of the specified ZTransform (i.e., a "copy constructor").
 The portion of the reference ZTransform that is duplicated is that necessary to reuse the ZTransform
 elsewhere, and so the new transform does not have a parent,</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
public java.lang.Object <B>clone</B>()</PRE>
<DL>
<DD>Duplicates the current ZTransform by using the copy constructor.
 See the copy constructor comments for complete information about what is duplicated.<DD><DL>
<DT><B>Overrides:</B><DD>clone in class java.lang.Object<DT><B>See Also: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#ZTransform(edu.umd.cs.jazz.scenegraph.ZTransform)"><CODE>ZTransform(ZTransform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAffineTransform()"><!-- --></A><H3>
getAffineTransform</H3>
<PRE>
public java.awt.geom.AffineTransform <B>getAffineTransform</B>()</PRE>
<DL>
<DD>Get copy of affine transform stored in the ZTransform.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getType()"><!-- --></A><H3>
getType</H3>
<PRE>
public int <B>getType</B>()</PRE>
<DL>
<DD>Return the type of transform as specified by AffineTransform.<DD><DL>
<DT><B>See Also: </B><DD><CODE>AffineTransform.getType()</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createInverse()"><!-- --></A><H3>
createInverse</H3>
<PRE>
public <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html">ZTransform</A> <B>createInverse</B>()</PRE>
<DL>
<DD>Create inverse ZTransform.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createInverseAffineTransform()"><!-- --></A><H3>
createInverseAffineTransform</H3>
<PRE>
public java.awt.geom.AffineTransform <B>createInverseAffineTransform</B>()</PRE>
<DL>
<DD>Create inverse affine transform stored in the ZTransform.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAffineTransform(java.awt.geom.AffineTransform)"><!-- --></A><H3>
setAffineTransform</H3>
<PRE>
public void <B>setAffineTransform</B>(java.awt.geom.AffineTransform&nbsp;tx)</PRE>
<DL>
<DD>Set the underlying affine transform that this ZTransform wraps.
 This call results in the scenegraph object associated with this transform
 to be damaged, and it and its children's bounds to be updated.
 The transform passed in is copied, and thus can be used by the caller
 afterwards without affecting this ZTransform.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tx</CODE> - The new affine transform</DL>
</DD>
</DL>
<HR>

<A NAME="setAffineTransform(double, double, double, double, double, double)"><!-- --></A><H3>
setAffineTransform</H3>
<PRE>
public void <B>setAffineTransform</B>(double&nbsp;m00,
                               double&nbsp;m10,
                               double&nbsp;m01,
                               double&nbsp;m11,
                               double&nbsp;m02,
                               double&nbsp;m12)</PRE>
<DL>
<DD>Set the underlying affine transform that this ZTransform wraps.
 This call results in the scenegraph object associated with this transform
 to be damaged, and it and its children's bounds to be updated.
 The transform passed in is copied, and thus can be used by the caller
 afterwards without affecting this ZTransform.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>m00,&nbsp;m01,&nbsp;m02,&nbsp;m10,&nbsp;m11,&nbsp;m12</CODE> - the
 6 floating point values that compose the 3x3 transformation matrix</DL>
</DD>
</DL>
<HR>

<A NAME="concatenate(java.awt.geom.AffineTransform)"><!-- --></A><H3>
concatenate</H3>
<PRE>
public void <B>concatenate</B>(java.awt.geom.AffineTransform&nbsp;tx)</PRE>
<DL>
<DD>Concatenates an <code>AffineTransform</code> <code>tx</code> to
 this <code>AffineTransform</code> Cx in the most commonly useful
 way to provide a new user space
 that is mapped to the former user space by <code>Tx</code>.
 Cx is updated to perform the combined transformation.
 Transforming a point p by the updated transform Cx' is
 equivalent to first transforming p by <code>Tx</code> and then
 transforming the result by the original transform Cx like this:
 Cx'(p) = Cx(Tx(p))  
 In matrix notation, if this transform Cx is
 represented by the matrix [this] and <code>Tx</code> is represented
 by the matrix [Tx] then this method does the following:
 <pre>
		[this] = [this] x [Tx]
 </pre><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Tx</CODE> - the <code>AffineTransform</code> object to be
 concatenated with this <code>AffineTransform</code> object.<DT><B>See Also: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#preConcatenate(java.awt.geom.AffineTransform)"><CODE>preConcatenate(java.awt.geom.AffineTransform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="preConcatenate(java.awt.geom.AffineTransform)"><!-- --></A><H3>
preConcatenate</H3>
<PRE>
public void <B>preConcatenate</B>(java.awt.geom.AffineTransform&nbsp;tx)</PRE>
<DL>
<DD>Concatenates an <code>AffineTransform</code> <code>Tx</code> to
 this <code>AffineTransform</code> Cx
 in a less commonly used way such that <code>Tx</code> modifies the
 coordinate transformation relative to the absolute pixel
 space rather than relative to the existing user space.
 Cx is updated to perform the combined transformation.
 Transforming a point p by the updated transform Cx' is
 equivalent to first transforming p by the original transform
 Cx and then transforming the result by 
 <code>Tx</code> like this: 
 Cx'(p) = Tx(Cx(p))  
 In matrix notation, if this transform Cx
 is represented by the matrix [this] and <code>Tx</code> is
 represented by the matrix [Tx] then this method does the
 following:
 <pre>
		[this] = [Tx] x [this]
 </pre><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Tx</CODE> - the <code>AffineTransform</code> object to be
 concatenated with this <code>AffineTransform</code> object.<DT><B>See Also: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#concatenate(java.awt.geom.AffineTransform)"><CODE>concatenate(java.awt.geom.AffineTransform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMatrix(double[])"><!-- --></A><H3>
getMatrix</H3>
<PRE>
public void <B>getMatrix</B>(double[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>Retrieves the 6 specifiable values in the 3x3 affine transformation
 matrix that this ZTransform wraps,
 and places them into an array of double precisions values.
 The values are stored in the array as 
 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}.
 An array of 4 doubles can also be specified, in which case only the
 first four elements representing the non-transform
 parts of the array are retrieved and the values are stored into 
 the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flatmatrix</CODE> - the double array used to store the returned
 values.</DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A><H3>
getParent</H3>
<PRE>
public <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZScenegraphObject.html">ZScenegraphObject</A> <B>getParent</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setParent(edu.umd.cs.jazz.scenegraph.ZScenegraphObject)"><!-- --></A><H3>
setParent</H3>
<PRE>
public void <B>setParent</B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZScenegraphObject.html">ZScenegraphObject</A>&nbsp;aParent)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A><H3>
transform</H3>
<PRE>
public java.awt.geom.Point2D <B>transform</B>(java.awt.geom.Point2D&nbsp;ptSrc,
                                       java.awt.geom.Point2D&nbsp;ptDst)</PRE>
<DL>
<DD>Transforms the specified <code>ptSrc</code> and stores the result
 in <code>ptDst</code>.
 If <code>ptDst</code> is <code>null</code>, a new <CODE>Point2D</CODE>
 object is allocated and then the result of the transformation is
 stored in this object.
 In either case, <code>ptDst</code>, which contains the
 transformed point, is returned for convenience.
 If <code>ptSrc</code> and <code>ptDst</code> are the same
 object, the input point is correctly overwritten with
 the transformed point.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptSrc</CODE> - the specified <code>Point2D</code> to be transformed<DD><CODE>ptDst</CODE> - the specified <code>Point2D</code> that stores the
 result of transforming <code>ptSrc</code><DT><B>Returns:</B><DD>the <code>ptDst</code> after transforming
 <code>ptSrc</code> and storing the result in <code>ptDst</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Point2D[], int, java.awt.geom.Point2D[], int, int)"><!-- --></A><H3>
transform</H3>
<PRE>
public void <B>transform</B>(java.awt.geom.Point2D[]&nbsp;ptSrc,
                      int&nbsp;srcOff,
                      java.awt.geom.Point2D[]&nbsp;ptDst,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>Transforms an array of point objects by this transform.
 If any element of the <code>ptDst</code> array is
 <code>null</code>, a new <code>Point2D</code> object is allocated
 and stored into that element before storing the results of the
 transformation.
 <p>
 Note that this method does not take any precautions to
 avoid problems caused by storing results into <code>Point2D</code>
 objects that will be used as the source for calculations
 further down the source array.
 This method does guarantee that if a specified <code>Point2D</code> 
 object is both the source and destination for the same single point
 transform operation then the results will not be stored until
 the calculations are complete to avoid storing the results on
 top of the operands.
 If, however, the destination <code>Point2D</code> object for one
 operation is the same object as the source <code>Point2D</code> 
 object for another operation further down the source array then
 the original coordinates in that point are overwritten before
 they can be converted.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptSrc</CODE> - the array containing the source point objects<DD><CODE>ptDst</CODE> - the array into which the transform point objects are
 returned<DD><CODE>srcOff</CODE> - the offset to the first point object to be
 transformed in the source array<DD><CODE>dstOff</CODE> - the offset to the location of the first
 transformed point object that is stored in the destination array<DD><CODE>numPts</CODE> - the number of point objects to be transformed</DL>
</DD>
</DL>
<HR>

<A NAME="transform(float[], int, float[], int, int)"><!-- --></A><H3>
transform</H3>
<PRE>
public void <B>transform</B>(float[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      float[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>Transforms an array of floating point coordinates by this transform.
 The two coordinate array sections can be exactly the same or
 can be overlapping sections of the same array without affecting the
 validity of the results.
 This method ensures that no source coordinates are overwritten by a
 previous operation before they can be transformed.
 The coordinates are stored in the arrays starting at the specified
 offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptSrc</CODE> - the array containing the source point coordinates.
 Each point is stored as a pair of x,&nbsp;y coordinates.<DD><CODE>ptDst</CODE> - the array into which the transformed point coordinates
 are returned.  Each point is stored as a pair of x,&nbsp;y
 coordinates.<DD><CODE>srcOff</CODE> - the offset to the first point to be transformed
 in the source array<DD><CODE>dstOff</CODE> - the offset to the location of the first
 transformed point that is stored in the destination array<DD><CODE>numPts</CODE> - the number of points to be transformed</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], int, double[], int, int)"><!-- --></A><H3>
transform</H3>
<PRE>
public void <B>transform</B>(double[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      double[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>Transforms an array of double precision coordinates by this transform.
 The two coordinate array sections can be exactly the same or
 can be overlapping sections of the same array without affecting the
 validity of the results.
 This method ensures that no source coordinates are
 overwritten by a previous operation before they can be transformed.
 The coordinates are stored in the arrays starting at the indicated
 offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srcPts</CODE> - the array containing the source point coordinates.
 Each point is stored as a pair of x,&nbsp;y coordinates.<DD><CODE>dstPts</CODE> - the array into which the transformed point
 coordinates are returned.  Each point is stored as a pair of
 x,&nbsp;y coordinates.<DD><CODE>srcOff</CODE> - the offset to the first point to be transformed
 in the source array<DD><CODE>dstOff</CODE> - the offset to the location of the first
 transformed point that is stored in the destination array<DD><CODE>numPts</CODE> - the number of point objects to be transformed</DL>
</DD>
</DL>
<HR>

<A NAME="transform(float[], int, double[], int, int)"><!-- --></A><H3>
transform</H3>
<PRE>
public void <B>transform</B>(float[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      double[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>Transforms an array of floating point coordinates by this transform
 and stores the results into an array of doubles.
 The coordinates are stored in the arrays starting at the specified
 offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ptSrc</CODE> - the array containing the source point coordinates.
 Each point is stored as a pair of x,&nbsp;y coordinates.<DD><CODE>ptDst</CODE> - the array into which the transformed point coordinates
 are returned.  Each point is stored as a pair of x,&nbsp;y
 coordinates.<DD><CODE>srcOff</CODE> - the offset to the first point to be transformed
 in the source array<DD><CODE>dstOff</CODE> - the offset to the location of the first
 transformed point that is stored in the destination array<DD><CODE>numPts</CODE> - the number of points to be transformed</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], int, float[], int, int)"><!-- --></A><H3>
transform</H3>
<PRE>
public void <B>transform</B>(double[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      float[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>Transforms an array of double precision coordinates by this transform
 and stores the results into an array of floats.
 The coordinates are stored in the arrays starting at the specified
 offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srcPts</CODE> - the array containing the source point coordinates.
 Each point is stored as a pair of x,&nbsp;y coordinates.<DD><CODE>dstPts</CODE> - the array into which the transformed point
 coordinates are returned.  Each point is stored as a pair of 
 x,&nbsp;y coordinates.<DD><CODE>srcOff</CODE> - the offset to the first point to be transformed
 in the source array<DD><CODE>dstOff</CODE> - the offset to the location of the first
 transformed point that is stored in the destination array<DD><CODE>numPts</CODE> - the number of point objects to be transformed</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
transform</H3>
<PRE>
public java.awt.geom.Rectangle2D <B>transform</B>(java.awt.geom.Rectangle2D&nbsp;rectSrc,
                                           java.awt.geom.Rectangle2D&nbsp;rectDst)</PRE>
<DL>
<DD>Transforms the specified <code>rectSrc</code> and stores the result
 in <code>rectDst</code>.
 If <code>rectDst</code> is <code>null</code>, a new <CODE>Rectangle2D</CODE>
 object is allocated and then the result of the transformation is
 stored in this object.
 In either case, <code>rectDst</code>, which contains the
 transformed point, is returned for convenience.
 If <code>rectSrc</code> and <code>rectDst</code> are the same
 object, the input rectangle is correctly overwritten with
 the transformed rectangle.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rectSrc</CODE> - the specified <code>Rectangle2D</code> to be transformed<DD><CODE>rectDst</CODE> - the specified <code>Rectangle2D</code> that stores the
 result of transforming <code>rectSrc</code><DT><B>Returns:</B><DD>the <code>rectDst</code> after transforming
 <code>rectSrc</code> and storing the result in <code>recttDst</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A><H3>
inverseTransform</H3>
<PRE>
public void <B>inverseTransform</B>(java.awt.geom.Point2D&nbsp;srcPt,
                             java.awt.geom.Point2D&nbsp;destPt)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="inverseTransform(java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D)"><!-- --></A><H3>
inverseTransform</H3>
<PRE>
public void <B>inverseTransform</B>(java.awt.geom.Rectangle2D&nbsp;srcRect,
                             java.awt.geom.Rectangle2D&nbsp;destRect)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="inverseTransform(java.awt.geom.Area)"><!-- --></A><H3>
inverseTransform</H3>
<PRE>
public void <B>inverseTransform</B>(java.awt.geom.Area&nbsp;area)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslation()"><!-- --></A><H3>
getTranslation</H3>
<PRE>
public java.awt.geom.Point2D <B>getTranslation</B>()</PRE>
<DL>
<DD>Returns the current translation of this object<DD><DL>
<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="translate(float, float)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(float&nbsp;dx,
                      float&nbsp;dy)</PRE>
<DL>
<DD>Translate the object by the specified deltaX and deltaY<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dx</CODE> - X-coord of translation<DD><CODE>dy</CODE> - Y-coord of translation</DL>
</DD>
</DL>
<HR>

<A NAME="translate(float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(float&nbsp;dx,
                      float&nbsp;dy,
                      int&nbsp;millis,
                      <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the object from its current position by the specified deltaX and deltaY<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dx</CODE> - X-coord of translation<DD><CODE>dy</CODE> - Y-coord of translation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="translateTo(float, float)"><!-- --></A><H3>
translateTo</H3>
<PRE>
public void <B>translateTo</B>(float&nbsp;x,
                        float&nbsp;y)</PRE>
<DL>
<DD>Translate the object to the specified position<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X-coord of translation<DD><CODE>y</CODE> - Y-coord of translation</DL>
</DD>
</DL>
<HR>

<A NAME="translateTo(float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
translateTo</H3>
<PRE>
public void <B>translateTo</B>(float&nbsp;x,
                        float&nbsp;y,
                        int&nbsp;millis,
                        <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the object from its current position to the positino specified
 by x, y<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X-coord of translation<DD><CODE>y</CODE> - Y-coord of translation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="getScale()"><!-- --></A><H3>
getScale</H3>
<PRE>
public float <B>getScale</B>()</PRE>
<DL>
<DD>Returns the current scale of this transform.
 Note that this is implemented by applying the transform to a diagonal
 line and returning the length of the resulting line.  If the transform
 is sheared, or has a non-uniform scaling in X and Y, the results of
 this method will be ill-defined.<DD><DL>
<DT><B>Returns:</B><DD>the scale</DL>
</DD>
</DL>
<HR>

<A NAME="scale(float)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(float&nbsp;dz)</PRE>
<DL>
<DD>Scale the object from its current scale to the scale specified
 by muliplying the current scale and dz.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor</DL>
</DD>
</DL>
<HR>

<A NAME="scale(float, float, float)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(float&nbsp;dz,
                  float&nbsp;x,
                  float&nbsp;y)</PRE>
<DL>
<DD>Scale the object around the specified point (x, y) 
 from its current scale to the scale specified
 by muliplying the current scale and dz.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around</DL>
</DD>
</DL>
<HR>

<A NAME="scale(float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(float&nbsp;dz,
                  int&nbsp;millis,
                  <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the object from its current scale to the scale specified
 by muliplying the current scale and deltaZ<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="scale(float, float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(float&nbsp;dz,
                  float&nbsp;x,
                  float&nbsp;y,
                  int&nbsp;millis,
                  <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the object around the specified point (x, y)
 from its current scale to the scale specified
 by muliplying the current scale and dz<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="scaleTo(float)"><!-- --></A><H3>
scaleTo</H3>
<PRE>
public void <B>scaleTo</B>(float&nbsp;finalz)</PRE>
<DL>
<DD>Set the scale of the object to the specified target scale.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>finalz</CODE> - final scale factor</DL>
</DD>
</DL>
<HR>

<A NAME="scaleTo(float, float, float)"><!-- --></A><H3>
scaleTo</H3>
<PRE>
public void <B>scaleTo</B>(float&nbsp;finalz,
                    float&nbsp;x,
                    float&nbsp;y)</PRE>
<DL>
<DD>Set the scale of the object to the specified target scale,
 scaling the object around the specified point (x, y).<DD><DL>
<DT><B>Parameters:</B><DD><CODE>finalz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around</DL>
</DD>
</DL>
<HR>

<A NAME="scaleTo(float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
scaleTo</H3>
<PRE>
public void <B>scaleTo</B>(float&nbsp;finalz,
                    int&nbsp;millis,
                    <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the object from its current scale to the specified target scale.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>finalz</CODE> - scale factor<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="scaleTo(float, float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
scaleTo</H3>
<PRE>
public void <B>scaleTo</B>(float&nbsp;finalz,
                    float&nbsp;x,
                    float&nbsp;y,
                    int&nbsp;millis,
                    <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the object around the specified point (x, y)
 to the specified target scale.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>finalz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="getRotation()"><!-- --></A><H3>
getRotation</H3>
<PRE>
public float <B>getRotation</B>()</PRE>
<DL>
<DD>Returns the current rotation (Z-axis) of this object
 Not currently immplemented BDMREV<DD><DL>
<DT><B>Returns:</B><DD>the scale</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(float)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(float&nbsp;theta)</PRE>
<DL>
<DD>Rotate the object by the specified amount<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(float, float, float)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(float&nbsp;theta,
                   float&nbsp;xctr,
                   float&nbsp;yctr)</PRE>
<DL>
<DD>Rotate the object by the specified amount around the specified anchor point<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>xctr</CODE> - X-coord of anchor point<DD><CODE>yctr</CODE> - Y-coord of anchor point</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(float&nbsp;theta,
                   int&nbsp;millis,
                   <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Rotate the object, via animation, theta radians<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>millis</CODE> - Time to animate scale in milliseconds<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(float, float, float, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(float&nbsp;theta,
                   float&nbsp;xctr,
                   float&nbsp;yctr,
                   int&nbsp;millis,
                   <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Rotate the object, via animation, theta radians about the specified anchor point<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="position(java.awt.geom.Point2D, java.awt.geom.Point2D, edu.umd.cs.jazz.scenegraph.ZNode, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
position</H3>
<PRE>
public void <B>position</B>(java.awt.geom.Point2D&nbsp;srcPt,
                     java.awt.geom.Point2D&nbsp;destPt,
                     <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZNode.html">ZNode</A>&nbsp;refNode,
                     int&nbsp;millis,
                     <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>This will calculate the necessary transform in order to make this
 transform's corresponding node appear at a particular position relative to the
 specified node.  The source point specifies a point in the
 unit square (0, 0) - (1, 1) that represents an anchor point on the
 corresponding node to this transform.  The destination point specifies
 an anchor point on the reference node.  The position method then
 computes the transform that results in transforming this node so that
 the source anchor point coincides with the reference anchor
 point. This can be useful for layout algorithms as it is
 straightforward to position one object relative to another.  
 <p>
 For example, If you have two nodes, A and B, and you call
 <PRE>
 Point2D srcPt = new Point2D.Float(1.0f, 0.0f);
 Point2D destPt = new Point2D.Float(0.0f, 0.0f);
 A.position(srcPt, destPt, B, 750);
 </PRE>
 The result is that A will move so that its upper-right corner is at
 the same place as the upper-left corner of B, and the transition will
 be smoothly animated over a period of 750 milliseconds.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srcPt</CODE> - The anchor point on this transform's node (normalized to a unit square)<DD><CODE>destPt</CODE> - The anchor point on destination bounds (normalized to a unit square)<DD><CODE>destBounds</CODE> - The bounds used to calculate this transform's node<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="position(java.awt.geom.Point2D, java.awt.geom.Point2D, java.awt.geom.Rectangle2D, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
position</H3>
<PRE>
public void <B>position</B>(java.awt.geom.Point2D&nbsp;srcPt,
                     java.awt.geom.Point2D&nbsp;destPt,
                     java.awt.geom.Rectangle2D&nbsp;destBounds,
                     int&nbsp;millis,
                     <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>This will calculate the necessary transform in order to make this
 transform's corresponding node appear at a particular position relative to the
 specified bounding box.  The source point specifies a point in the
 unit square (0, 0) - (1, 1) that represents an anchor point on the
 corresponding node to this transform.  The destination point specifies
 an anchor point on the reference node.  The position method then
 computes the transform that results in transforming this node so that
 the source anchor point coincides with the reference anchor
 point. This can be useful for layout algorithms as it is
 straightforward to position one object relative to another.  
 <p>
 For example, If you have two nodes, A and B, and you call
 <PRE>
 Point2D srcPt = new Point2D.Float(1.0f, 0.0f);
 Point2D destPt = new Point2D.Float(0.0f, 0.0f);
 A.position(srcPt, destPt, B.getGlobalBounds(), 750);
 </PRE>
 The result is that A will move so that its upper-right corner is at
 the same place as the upper-left corner of B, and the transition will
 be smoothly animated over a period of 750 milliseconds.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srcPt</CODE> - The anchor point on this transform's node (normalized to a unit square)<DD><CODE>destPt</CODE> - The anchor point on destination bounds (normalized to a unit square)<DD><CODE>destBounds</CODE> - The bounds used to calculate this transform's node<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="animate(java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
animate</H3>
<PRE>
public void <B>animate</B>(java.awt.geom.AffineTransform&nbsp;tx,
                    int&nbsp;millis,
                    <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Set the transform of this object to the specified transform, 
 and animate the change from its current transformation over the specified
 number of milliseconds using a slow-in slow-out animation.
 The surface specifies which surface should be updated during the animation.  
 (Note that another version of animate lets you specify the timing of
 the animation so you can avoid the slow-in slow-out animation if you prefer.)
 <p>
 If millis is 0, then the transform is updated once, and the scene
 is damaged, but not restored - and thus there are no visible changes
 on any surface.  The caller must call surface.restore().
 In this case, the surface is not used, and can be specified as null.
 <p>
 If this transform's parent is null, then there is nothing to animate,
 and so the transform will just be set directly to the specified transform
 without any animation.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tx</CODE> - Final transformation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.<DT><B>See Also: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#animate(java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.scenegraph.ZSurface, edu.umd.cs.jazz.util.ZLerp)"><CODE>animate(AffineTransform, int, ZSurface, ZLerp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="animate(java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.scenegraph.ZSurface, edu.umd.cs.jazz.util.ZLerp)"><!-- --></A><H3>
animate</H3>
<PRE>
public void <B>animate</B>(java.awt.geom.AffineTransform&nbsp;tx,
                    int&nbsp;millis,
                    <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface,
                    <A HREF="../../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</PRE>
<DL>
<DD>Set the transform of this object to the specified transform, 
 and animate the change from its current transformation over the specified
 number of milliseconds.
 The surface specifies which surface should be updated during the animation.  
 <p>
 If millis is 0, then the transform is updated once, and the scene
 is damaged, but not restored - and thus there are no visible changes
 on any surface.  The caller must call surface.restore().
 In this case, the surface is not used, and can be specified as null.
 <p>
 The timing of the animation is controlled by the <tt>lerpTimeFunction</tt>.
 This is used to specify the rate the animation occurs over time.  If this
 parameter is specified as null, then a standard linear interpolation is
 used, and the animation goes at a constant speed from beginning to end.
 The caller can specify alternate functions, however, which can do things
 like perform a slow-in, slow-out animation.
 <p>
 If this transform's parent is null, then there is nothing to animate,
 and so the transform will just be set directly to the specified transform
 without any animation.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tx</CODE> - Final transformation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.<DD><CODE>lerpTimeFunction</CODE> - The function that determines how the timing of the animation should be calculated<DT><B>See Also: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#animate(java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.scenegraph.ZSurface)"><CODE>animate(AffineTransform, int, ZSurface)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="animate(edu.umd.cs.jazz.scenegraph.ZNode[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.scenegraph.ZSurface)"><!-- --></A><H3>
animate</H3>
<PRE>
public static void <B>animate</B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZNode.html">ZNode</A>[]&nbsp;nodes,
                           java.awt.geom.AffineTransform[]&nbsp;txs,
                           int&nbsp;millis,
                           <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Set the transforms of the specified array of nodes to the specified
 array of transforms,
 and animate the change over the specified
 number of milliseconds using a slow-in slow-out animation.
 The surface specifies which surface should be updated during the animation.
 (Note that another version of animate lets you specify the timing of
 the animation so you can avoid the slow-in slow-out animation if you prefer.)
 <p>
 If the size of the nodes and txs arrays are not equal, then only those
 nodes for which transforms are specified will be animated.  That is,
 the smaller of the two array sizes will be used.
 <p>
 If millis is 0, then the transforms are updated once, and the scene
 is damaged, but not restored - and thus there are no visible changes
 on any surface.  The caller must call surface.restore().
 In this case, the surface is not used, and can be specified as null.
 <p>
 The following code fragment demonstrates the use of this animate
 method.  It creates three rectangles, and animates two of them
 simultaneously.
 <pre>
     ZRectangle rect1, rect2, rect3;
     ZNode node1, node2, node3;

     rect1 = new ZRectangle(0, 0, 50, 50);
     rect1.setFillColor(Color.red);
     node1 = new ZNode(rect1);
     drawingLayer.addChild(node1);

     rect2 = new ZRectangle(25, 25, 50, 50);
     rect2.setFillColor(Color.blue);
     node2 = new ZNode(rect2);
     drawingLayer.addChild(node2);

     rect3 = new ZRectangle(100, 100, 50, 50);
     rect3.setFillColor(Color.orange);
     node3 = new ZNode(rect3);
     drawingLayer.addChild(node3);

     ZNode[] nodes = new ZNode[2];
     nodes[0] = node1;
     nodes[1] = node2;
     AffineTransform[] txs = new AffineTransform[2];
     txs[0] = new AffineTransform();
     txs[0].scale(2.0f, 2.0f);
     txs[1] = new AffineTransform();
     txs[1].translate(100.0f, 25.0f);
     txs[1].scale(0.5f, 0.5f);

     ZTransform.animate(nodes, txs, 1000, surface);
 </pre><DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodes</CODE> - The array of nodes to be animated<DD><CODE>txs</CODE> - The array of final transformations of the nodes<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.<DT><B>See Also: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZTransform.html#animate(edu.umd.cs.jazz.scenegraph.ZNode[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.scenegraph.ZSurface, edu.umd.cs.jazz.util.ZLerp)"><CODE>animate(ZNode[], AffineTransform[], int, ZSurface, ZLerp)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="animate(edu.umd.cs.jazz.scenegraph.ZNode[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.scenegraph.ZSurface, edu.umd.cs.jazz.util.ZLerp)"><!-- --></A><H3>
animate</H3>
<PRE>
public static void <B>animate</B>(<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZNode.html">ZNode</A>[]&nbsp;nodes,
                           java.awt.geom.AffineTransform[]&nbsp;txs,
                           int&nbsp;millis,
                           <A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html">ZSurface</A>&nbsp;surface,
                           <A HREF="../../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</PRE>
<DL>
<DD>Set the transforms of the specified array of nodes to the specified
 array of transforms, and animate the change over the specified
 number of milliseconds.
 The surface specifies which surface should be updated during the animation.
 <p>
 If the size of the nodes and txs arrays are not equal, then only those
 nodes for which transforms are specified will be animated.  That is,
 the smaller of the two array sizes will be used.
 <p>
 If millis is 0, then the transforms are updated once, and the scene
 is damaged, but not restored - and thus there are no visible changes
 on any surface.  The caller must call surface.restore().
 In this case, the surface is not used, and can be specified as null.
 <p>
 The timing of the animation is controlled by the <tt>lerpTimeFunction</tt>.
 This is used to specify the rate the animation occurs over time.  If this
 parameter is specified as null, then a standard linear interpolation is
 used, and the animation goes at a constant speed from beginning to end.
 The caller can specify alternate functions, however, which can do things
 like perform a slow-in, slow-out animation.
 <p>
 The following code fragment demonstrates the use of this animate
 method.  It creates three rectangles, and animates two of them
 simultaneously.
 <pre>
     ZRectangle rect1, rect2, rect3;
     ZNode node1, node2, node3;

     rect1 = new ZRectangle(0, 0, 50, 50);
     rect1.setFillColor(Color.red);
     node1 = new ZNode(rect1);
     drawingLayer.addChild(node1);

     rect2 = new ZRectangle(25, 25, 50, 50);
     rect2.setFillColor(Color.blue);
     node2 = new ZNode(rect2);
     drawingLayer.addChild(node2);

     rect3 = new ZRectangle(100, 100, 50, 50);
     rect3.setFillColor(Color.orange);
     node3 = new ZNode(rect3);
     drawingLayer.addChild(node3);

     ZNode[] nodes = new ZNode[2];
     nodes[0] = node1;
     nodes[1] = node2;
     AffineTransform[] txs = new AffineTransform[2];
     txs[0] = new AffineTransform();
     txs[0].scale(2.0f, 2.0f);
     txs[1] = new AffineTransform();
     txs[1].translate(100.0f, 25.0f);
     txs[1].scale(0.5f, 0.5f);

     ZTransform.animate(nodes, txs, 1000, surface);
 </pre><DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodes</CODE> - The array of nodes to be animated<DD><CODE>txs</CODE> - The array of final transformations of the nodes<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.<DD><CODE>lerpTimeFunction</CODE> - The function that determines how the timing of the animation should be calculated</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Generate a string that represents this object for debugging.<DD><DL>
<DT><B>Returns:</B><DD>the string that represents this object for debugging<DT><B>Overrides:</B><DD>toString in class java.lang.Object</DL>
</DD>
</DL>
<HR>

<A NAME="writeObject(edu.umd.cs.jazz.io.ZObjectOutputStream)"><!-- --></A><H3>
writeObject</H3>
<PRE>
public void <B>writeObject</B>(<A HREF="../../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)
                 throws java.io.IOException</PRE>
<DL>
<DD>Write out all of this object's state.<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/io/ZSerializable.html#writeObject(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObject</A> in interface <A HREF="../../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A><DT><B>Parameters:</B><DD><CODE>out</CODE> - The stream that this object writes into</DL>
</DD>
</DL>
<HR>

<A NAME="writeObjectRecurse(edu.umd.cs.jazz.io.ZObjectOutputStream)"><!-- --></A><H3>
writeObjectRecurse</H3>
<PRE>
public void <B>writeObjectRecurse</B>(<A HREF="../../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)
                        throws java.io.IOException</PRE>
<DL>
<DD>Specify which objects this object references in order to write out the scenegraph properly<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/io/ZSerializable.html#writeObjectRecurse(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObjectRecurse</A> in interface <A HREF="../../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A><DT><B>Parameters:</B><DD><CODE>out</CODE> - The stream that this object writes into</DL>
</DD>
</DL>
<HR>

<A NAME="setState(java.lang.String, java.lang.String, java.lang.Object)"><!-- --></A><H3>
setState</H3>
<PRE>
public void <B>setState</B>(java.lang.String&nbsp;fieldType,
                     java.lang.String&nbsp;fieldName,
                     java.lang.Object&nbsp;fieldValue)</PRE>
<DL>
<DD>Set some state of this object as it gets read back in.
 After the object is created with its default no-arg constructor,
 this method will be called on the object once for each bit of state
 that was written out through calls to ZObjectOutputStream.writeState()
 within the writeObject method.<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../../edu/umd/cs/jazz/io/ZSerializable.html#setState(java.lang.String, java.lang.String, java.lang.Object)">setState</A> in interface <A HREF="../../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A><DT><B>Parameters:</B><DD><CODE>fieldType</CODE> - The fully qualified type of the field<DD><CODE>fieldName</CODE> - The name of the field<DD><CODE>fieldValue</CODE> - The value of the field</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" ID="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" ID="NavBarCell1Rev"> &nbsp;<FONT ID="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZSurface.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../edu/umd/cs/jazz/scenegraph/ZVisualComponent.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ZTransform.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
