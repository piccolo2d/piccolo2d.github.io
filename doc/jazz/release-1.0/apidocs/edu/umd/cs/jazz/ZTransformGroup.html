<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon Jul 03 12:34:37 EDT 2000 -->
<TITLE>
Jazz API Documentation: Class  ZTransformGroup
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ZTransformGroup.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Jazz API Documentation</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../edu/umd/cs/jazz/ZStickyGroup.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../edu/umd/cs/jazz/ZTreeLayoutManager.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ZTransformGroup.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_edu.umd.cs.jazz.ZGroup">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
edu.umd.cs.jazz</FONT>
<BR>
Class  ZTransformGroup</H2>
<PRE>
java.lang.Object
  |
  +--<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html">edu.umd.cs.jazz.ZSceneGraphObject</A>
        |
        +--<A HREF="../../../../edu/umd/cs/jazz/ZNode.html">edu.umd.cs.jazz.ZNode</A>
              |
              +--<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">edu.umd.cs.jazz.ZGroup</A>
                    |
                    +--<B>edu.umd.cs.jazz.ZTransformGroup</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable, java.io.Serializable, <A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A>, <A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../edu/umd/cs/jazz/ZConstraintGroup.html">ZConstraintGroup</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>ZTransformGroup</B><DT>extends <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A><DT>implements <A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A>, <A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>, java.io.Serializable</DL>

<P>
<b>ZTransformGroup</b> is a group node that specifies an arbitrary affine transform. 
 The transform applies to all the children of this node.
 In addition, it provides some extra manipulators
 on the transform.  This provides the ability to relatively or absolutely change
 the translation, scale, rotation and shear of the transform - either immediately,
 or animated over time.
 <p>
 In order to use transforms effectively, it is important to have a solid understanding
 of affine transforms, matrix multiplication, and the standard use of matrices for
 graphics coordinate systems.  The best place to start is by reading the documentation
 on <CODE>AffineTransform</CODE>.  After that, a good next bit is to read
 a standard 3D graphics text such as "Interactive Computer Graphics: a Top-Down Approach
 with OpenGL" 2nd Edition by Angel (Addison-Wesley), or "Computer Graphics: Principles
 and Practice, Second Edition in C" by Foley, van Dam, Feiner, Hughes, and Phillips
 (Addison-Wesley).
 <p>
 Here is a very short lesson on matrices and graphics.  A 2D affine transform is typically
 represented by a 3x3 matrix which we typically call M, and sometimes denote [M].  An
 affine transform can represent any 2D translation, scale, rotation, shear or any combination
 of these 4 operators.  Matrices which are pure translations, scales, and rotations are
 typically denoted T, S, or R ([T], [S], or [R]), respectively.  The identity matrix
 is typically denoted I or [I].
 <p>
 The reason these transforms are so powerful is because they can be combined in a
 semantically straightforward way by simply concatenating the matrices.  Creating
 a transform results in I.  Calling one of the transformation methods on a transform is exactly equivalent to
 concatenating the transform with a new transform that specifies the transformation.
 Thus, transform.translate(dx, dy) is equivalent to [M][T] where M represents the original
 transform, and T represents the translation matrix of dx, dy.  Similarly, transform.scale(ds)
 is equivalent to [M][S].  And, these build up, so
 <pre>
    ZTransformGroup t = new ZTransformGroup();
    t.scale(ds);
    t.translate(dx, dy);
    t.rotate(Math.PI * 0.5);
 </pre>
 is equivalent to generating a node with  transform of these four matrices concatenated together with standard
 matrix multiplication [I][S][T][R]
 <p>
 However, a crucial place for confusion with these transforms is that the transforms
 get applied in the <em>reverse</em> order of how you placed the calls to the transforms
 in your code.  To understand this, you must realize that the object paint methods
 get called <em>after</em> the transformations are applied.  Your paint methods specify
 geometry (such as points) which get transformed by the current transformation before
 being painted.  For a simple example, think of a point P.  Well, the point
 post-multiplies the current transformation.  In the example above, that works out
 to a new point P' being computed as P' = [S][T][R]P.  You can think about this
 as the original point P first getting multiplied (on the left) by R, then the result
 gets multipled (on the left) by T, and that gets multiplied (on the left) by S.
 <p>
 Let's go through a simple example with actual numbers.  Suppose you want to take a
 rectangle at (0, 0) with width 50 and height 50, and first translate it 50 units to the right,
 and then scale the whole thing by 2 about the origin.
 The result should be that the rectangle actually gets rendered at (100, 0) with dimensions
 of (100x100).  The following code in Jazz implements this example.
 <pre>
    ZRectangle rect = new ZRectangle(0, 0, 50, 50);
    ZVisualLeaf leaf = new ZVisualLeaf(rect);
    ZTransformGroup node = new ZTransformGroup();
    node.addChild(leaf);
    layer.addChild(node);

				// Note how we call scale first even though
				// the translation will actually be applied before the scale.
    node.scale(2);
    node.translate(50, 0);
 </pre>
 <p>
 Sometimes it is useful to transform an object in global coordinates - even though
 that object has a transform of its own.  For instance, suppose you are implementing an
 event handler for selection, and want to move an object so that it follows the pointer.
 In order to do this, you need to translate the object in <em>global</em> coordinates.
 Since the node you want to move may have a transform already (for instance, it may be scaled),
 if you simply translate the object, that transform will be applied <em>after</em> the
 scale, and thus the translation will be modified by the scale.  That is, the object
 may have the matrix [M].  Calling translate will generate [M][T].  If M represents a scale of 2,
 then the translation will actually translate twice as much as you intended.
 <p>
 The solution is to convert your translation into the local coordinate system of the object.
 Since there this node is actually part of a tree, there coul be other transforms as
 well, not to mention the camera transform.  So, the goal is to take the amount you want
 to translate the object in the original coordinate system (in this case the window coords),
 and convert it into the object's local coordinate system.  We do this by building up the
 concatenation of all the transforms from the window to the node, taking the inverse of
 that matrix, and finally transform the translation by the resulting inverse matrix.
 Jazz provides a utility method to make this easier.  So, the resulting code would
 look like this.  It takes a desired translation in window coordinates, and uses
 the utility method ZCamera.cameraToLocal to convert it to the local coordinate
 system of the specified node, and finally translates the node by the resulting amount.
 <pre>
    Point2D pt = new Point2D.Double(x, y);
    camera.cameraToLocal(pt, node);
    node.translate(pt.getX(), pt.getY());
 </pre>

 <P>
 <A HREF="../../../../edu/umd/cs/jazz/util/ZSceneGraphEditor.html"><CODE>ZSceneGraphEditor</CODE></A> provides a convenience mechanism to locate, create 
 and manage nodes of this type.
 <P>
 <b>Warning:</b> Serialized and ZSerialized objects of this class will not be
 compatible with future Jazz releases. The current serialization support is
 appropriate for short term storage or RMI between applications running the
 same version of Jazz. A future release of Jazz will provide support for long
 term persistence.
<P>
<DL>
<DT><B>See Also: </B><DD><CODE>AffineTransform</CODE>, <A HREF="../../../../serialized-form.html#edu.umd.cs.jazz.ZTransformGroup">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="fields_inherited_from_class_edu.umd.cs.jazz.ZGroup"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class edu.umd.cs.jazz.<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#childrenFindable_DEFAULT">childrenFindable_DEFAULT</A>,  
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#childrenPickable_DEFAULT">childrenPickable_DEFAULT</A>,  
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#hasOneChild_DEFAULT">hasOneChild_DEFAULT</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_edu.umd.cs.jazz.ZNode"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class edu.umd.cs.jazz.<A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../edu/umd/cs/jazz/ZNode.html#findable_DEFAULT">findable_DEFAULT</A>,  
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#listenerList">listenerList</A>,  
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#pickable_DEFAULT">pickable_DEFAULT</A>,  
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#savable_DEFAULT">savable_DEFAULT</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_edu.umd.cs.jazz.ZSceneGraphObject"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class edu.umd.cs.jazz.<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html">ZSceneGraphObject</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#bounds">bounds</A>,  
<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#volatileBounds">volatileBounds</A>,  
<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#volatileBounds_DEFAULT">volatileBounds_DEFAULT</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#ZTransformGroup()">ZTransformGroup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an empty ZTransformGroup.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#ZTransformGroup(edu.umd.cs.jazz.ZNode)">ZTransformGroup</A></B>(<A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a new transform group node with the specified node as a child of the
 new group.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#addTransformListener(edu.umd.cs.jazz.event.ZTransformListener)">addTransformListener</A></B>(<A HREF="../../../../edu/umd/cs/jazz/event/ZTransformListener.html">ZTransformListener</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the specified transform listener to receive transform events from this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#animate(edu.umd.cs.jazz.ZTransformable[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.ZDrawingSurface)">animate</A></B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>[]&nbsp;nodes,
        java.awt.geom.AffineTransform[]&nbsp;txs,
        int&nbsp;millis,
        <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transforms of the specified array of nodes to the specified
 array of transforms,
 and animate the change over the specified
 number of milliseconds using a slow-in slow-out animation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#animate(edu.umd.cs.jazz.ZTransformable[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.ZDrawingSurface, edu.umd.cs.jazz.util.ZLerp)">animate</A></B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>[]&nbsp;nodes,
        java.awt.geom.AffineTransform[]&nbsp;txs,
        int&nbsp;millis,
        <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface,
        <A HREF="../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transforms of the specified array of nodes to the specified
 array of transforms,
 and animate the change over the specified
 number of milliseconds using a slow-in slow-out animation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#animate(edu.umd.cs.jazz.ZTransformable, java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.ZDrawingSurface)">animate</A></B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>&nbsp;node,
        java.awt.geom.AffineTransform&nbsp;tx,
        int&nbsp;millis,
        <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transform of the specified node to the specified transform,
 and animate the change from its current transformation over the specified
 number of milliseconds using a slow-in slow-out animation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#animate(edu.umd.cs.jazz.ZTransformable, java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.ZDrawingSurface, edu.umd.cs.jazz.util.ZLerp)">animate</A></B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>&nbsp;node,
        java.awt.geom.AffineTransform&nbsp;at,
        int&nbsp;millis,
        <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface,
        <A HREF="../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the transform of the specified node to the specified transform,
 and animate the change from its current transformation over the specified
 number of milliseconds using a slow-in slow-out animation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#computeBounds()">computeBounds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recomputes and caches the bounds for this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#computeInverseTransform()">computeInverseTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internal method to compute the inverse transform based on the transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#computeScale(java.awt.geom.AffineTransform)">computeScale</A></B>(java.awt.geom.AffineTransform&nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given an AffineTransform, this returns the
 "scale" of the transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#concatenate(java.awt.geom.AffineTransform)">concatenate</A></B>(java.awt.geom.AffineTransform&nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concatenates an AffineTransform <code>at</code> to this node's transform in
 the standard way.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#dump()">dump</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a string that represents this object for debugging.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#duplicateObject()">duplicateObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a clone of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#fireTransformEvent(int, java.awt.geom.AffineTransform)">fireTransformEvent</A></B>(int&nbsp;id,
                   java.awt.geom.AffineTransform&nbsp;origTransform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notifies all listeners that have registered interest for
 notification on this event type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.AffineTransform</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getInverseTransform()">getInverseTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the inverse of the transform associated with this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.AffineTransform</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getLocalToGlobalTransform()">getLocalToGlobalTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the transform that converts local coordinates at this node to global coordinates
 at the root node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getMatrix(double[])">getMatrix</A></B>(double[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the 6 specifiable values in the affine transformation,
 and places them into an array of double precisions values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getRotation()">getRotation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current rotation of this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getScale()">getScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current scale of this transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.AffineTransform</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getTransform()">getTransform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a copy of the transform that that this node specifies.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getTranslateX()">getTranslateX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current X translation of this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getTranslateY()">getTranslateY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current Y translation of this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.geom.Point2D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#getTranslation()">getTranslation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current translation of this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#lerp(double, double, double)">lerp</A></B>(double&nbsp;t,
     double&nbsp;a,
     double&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearly interpolates between a and b, based on t.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#pick(java.awt.geom.Rectangle2D, edu.umd.cs.jazz.util.ZSceneGraphPath)">pick</A></B>(java.awt.geom.Rectangle2D&nbsp;rect,
     <A HREF="../../../../edu/umd/cs/jazz/util/ZSceneGraphPath.html">ZSceneGraphPath</A>&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first object under the specified rectangle (if there is one)
 in the subtree rooted with this as searched in reverse (front-to-back) order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#position(java.awt.geom.Point2D, java.awt.geom.Point2D, java.awt.geom.Rectangle2D, int, edu.umd.cs.jazz.ZDrawingSurface)">position</A></B>(java.awt.geom.Point2D&nbsp;srcPt,
         java.awt.geom.Point2D&nbsp;destPt,
         java.awt.geom.Rectangle2D&nbsp;destBounds,
         int&nbsp;millis,
         <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This will calculate the necessary transform in order to make this
 node appear at a particular position relative to the
 specified bounding box.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#position(java.awt.geom.Point2D, java.awt.geom.Point2D, edu.umd.cs.jazz.ZNode, int, edu.umd.cs.jazz.ZDrawingSurface)">position</A></B>(java.awt.geom.Point2D&nbsp;srcPt,
         java.awt.geom.Point2D&nbsp;destPt,
         <A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A>&nbsp;refNode,
         int&nbsp;millis,
         <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This will calculate the necessary transform in order to make this
 node appear at a particular position relative to the
 specified node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#preConcatenate(java.awt.geom.AffineTransform)">preConcatenate</A></B>(java.awt.geom.AffineTransform&nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pre-Concatenates an AffineTransform <code>at</code> to this node's transform in a less commonly
 used way such that <code>at</code> gets pre-multipled with the existing transform rather
 than the more normal post-multiplication.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#removeTransformListener(edu.umd.cs.jazz.event.ZTransformListener)">removeTransformListener</A></B>(<A HREF="../../../../edu/umd/cs/jazz/event/ZTransformListener.html">ZTransformListener</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified transform listener so that it no longer
 receives transform events from this transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#render(edu.umd.cs.jazz.util.ZRenderContext)">render</A></B>(<A HREF="../../../../edu/umd/cs/jazz/util/ZRenderContext.html">ZRenderContext</A>&nbsp;renderContext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders this node which results in its children getting painted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#repaint(edu.umd.cs.jazz.util.ZBounds)">repaint</A></B>(<A HREF="../../../../edu/umd/cs/jazz/util/ZBounds.html">ZBounds</A>&nbsp;repaintBounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method to pass repaint methods up the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#repaint(edu.umd.cs.jazz.ZSceneGraphObject, java.awt.geom.AffineTransform, edu.umd.cs.jazz.util.ZBounds)">repaint</A></B>(<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html">ZSceneGraphObject</A>&nbsp;obj,
        java.awt.geom.AffineTransform&nbsp;at,
        <A HREF="../../../../edu/umd/cs/jazz/util/ZBounds.html">ZBounds</A>&nbsp;clipBounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method to pass repaint methods up the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#rotate(double)">rotate</A></B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the node by the specified amount</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#rotate(double, double, double)">rotate</A></B>(double&nbsp;theta,
       double&nbsp;xctr,
       double&nbsp;yctr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the node by the specified amount around the specified anchor point</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#rotate(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)">rotate</A></B>(double&nbsp;theta,
       double&nbsp;xctr,
       double&nbsp;yctr,
       int&nbsp;millis,
       <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the node, via animation, theta radians about the specified anchor point</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#rotate(double, int, edu.umd.cs.jazz.ZDrawingSurface)">rotate</A></B>(double&nbsp;theta,
       int&nbsp;millis,
       <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotate the node, via animation, theta radians</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#scale(double)">scale</A></B>(double&nbsp;dz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale the node from its current scale to the scale specified
 by muliplying the current scale and dz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#scale(double, double, double)">scale</A></B>(double&nbsp;dz,
      double&nbsp;x,
      double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale the node around the specified point (x, y)
 from its current scale to the scale specified
 by muliplying the current scale and dz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#scale(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)">scale</A></B>(double&nbsp;dz,
      double&nbsp;x,
      double&nbsp;y,
      int&nbsp;millis,
      <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the node around the specified point (x, y)
 from its current scale to the scale specified
 by muliplying the current scale and dz</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#scale(double, int, edu.umd.cs.jazz.ZDrawingSurface)">scale</A></B>(double&nbsp;dz,
      int&nbsp;millis,
      <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the node from its current scale to the scale specified
 by muliplying the current scale and deltaZ</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setRotation(double)">setRotation</A></B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the absolute rotation of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setRotation(double, double, double)">setRotation</A></B>(double&nbsp;theta,
            double&nbsp;xctr,
            double&nbsp;yctr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the absolute rotation of this node, rotating around the specified anchor point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setRotation(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)">setRotation</A></B>(double&nbsp;theta,
            double&nbsp;xctr,
            double&nbsp;yctr,
            int&nbsp;millis,
            <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the absolute rotation of this node, via animation, theta radians about the specified anchor point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setRotation(double, int, edu.umd.cs.jazz.ZDrawingSurface)">setRotation</A></B>(double&nbsp;theta,
            int&nbsp;millis,
            <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the absolute rotation of this node, animating the change over time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setScale(double)">setScale</A></B>(double&nbsp;finalz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the scale of the transform</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setScale(double, double, double)">setScale</A></B>(double&nbsp;finalz,
         double&nbsp;x,
         double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the scale of the node to the specified target scale,
 scaling the node around the specified point (x, y).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setScale(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)">setScale</A></B>(double&nbsp;finalz,
         double&nbsp;x,
         double&nbsp;y,
         int&nbsp;millis,
         <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the node around the specified point (x, y)
 to the specified target scale.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setScale(double, int, edu.umd.cs.jazz.ZDrawingSurface)">setScale</A></B>(double&nbsp;finalz,
         int&nbsp;millis,
         <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the node from its current scale to the specified target scale.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setState(java.lang.String, java.lang.String, java.lang.Object)">setState</A></B>(java.lang.String&nbsp;fieldType,
         java.lang.String&nbsp;fieldName,
         java.lang.Object&nbsp;fieldValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set some state of this object as it gets read back in.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setTransform(java.awt.geom.AffineTransform)">setTransform</A></B>(java.awt.geom.AffineTransform&nbsp;newTransform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the transform associated with this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setTransform(double, double, double, double, double, double)">setTransform</A></B>(double&nbsp;m00,
             double&nbsp;m10,
             double&nbsp;m01,
             double&nbsp;m11,
             double&nbsp;m02,
             double&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the transform associated with this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setTranslateX(double)">setTranslateX</A></B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current X translation of this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setTranslateY(double)">setTranslateY</A></B>(double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current Y translation of this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setTranslation(double, double)">setTranslation</A></B>(double&nbsp;x,
               double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translate the node to the specified position</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#setTranslation(double, double, int, edu.umd.cs.jazz.ZDrawingSurface)">setTranslation</A></B>(double&nbsp;x,
               double&nbsp;y,
               int&nbsp;millis,
               <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the node from its current position to the position specified
 by x, y</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#transform(java.awt.geom.Rectangle2D, java.awt.geom.AffineTransform)">transform</A></B>(java.awt.geom.Rectangle2D&nbsp;rect,
          java.awt.geom.AffineTransform&nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apply the specified transform to the specified rectangle, modifying the rect.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#transform(edu.umd.cs.jazz.util.ZBounds, java.awt.geom.AffineTransform)">transform</A></B>(<A HREF="../../../../edu/umd/cs/jazz/util/ZBounds.html">ZBounds</A>&nbsp;bounds,
          java.awt.geom.AffineTransform&nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apply the specified transform to the specified bounds, modifying the bounds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#translate(double, double)">translate</A></B>(double&nbsp;dx,
          double&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translate the node by the specified deltaX and deltaY</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#translate(double, double, int, edu.umd.cs.jazz.ZDrawingSurface)">translate</A></B>(double&nbsp;dx,
          double&nbsp;dy,
          int&nbsp;millis,
          <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Animate the node from its current position by the specified deltaX and deltaY</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#writeObject(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObject</A></B>(<A HREF="../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write out all of this object's state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#writeObjectRecurse(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObjectRecurse</A></B>(<A HREF="../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify which objects this object references in order to write out the scenegraph properly</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_edu.umd.cs.jazz.ZGroup"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class edu.umd.cs.jazz.<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#addChild(edu.umd.cs.jazz.ZNode)">addChild</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#addChildImpl(edu.umd.cs.jazz.ZNode, boolean)">addChildImpl</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#addGroupListener(edu.umd.cs.jazz.event.ZGroupListener)">addGroupListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#extract()">extract</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#findNodes(edu.umd.cs.jazz.util.ZFindFilter, java.util.ArrayList)">findNodes</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#fireGroupEvent(int, edu.umd.cs.jazz.ZNode, boolean)">fireGroupEvent</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getChild(int)">getChild</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getChildren()">getChildren</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getChildrenFindable()">getChildrenFindable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getChildrenIterator()">getChildrenIterator</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getChildrenPickable()">getChildrenPickable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getChildrenReference()">getChildrenReference</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getNumChildren()">getNumChildren</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#getVolatileBounds()">getVolatileBounds</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#hasOneChild()">hasOneChild</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#indexOf(edu.umd.cs.jazz.ZNode)">indexOf</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#insertAbove(edu.umd.cs.jazz.ZNode)">insertAbove</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#iterator()">iterator</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#lower(edu.umd.cs.jazz.ZNode)">lower</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#lowerTo(edu.umd.cs.jazz.ZNode, edu.umd.cs.jazz.ZNode)">lowerTo</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#raise(edu.umd.cs.jazz.ZNode)">raise</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#raiseTo(edu.umd.cs.jazz.ZNode, edu.umd.cs.jazz.ZNode)">raiseTo</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#removeAllChildren()">removeAllChildren</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#removeChild(int)">removeChild</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#removeChild(edu.umd.cs.jazz.ZNode)">removeChild</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#removeChild(edu.umd.cs.jazz.ZNode, boolean)">removeChild</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#removeChildImpl(int, boolean)">removeChildImpl</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#removeGroupListener(edu.umd.cs.jazz.event.ZGroupListener)">removeGroupListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#removeNodeListener(edu.umd.cs.jazz.event.ZNodeListener)">removeNodeListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#setChildrenFindable(boolean)">setChildrenFindable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#setChildrenPickable(boolean)">setChildrenPickable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#setHasOneChild(boolean)">setHasOneChild</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#trimToSize()">trimToSize</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#updateHasNodeListener()">updateHasNodeListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#updateVolatility()">updateVolatility</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_edu.umd.cs.jazz.ZNode"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class edu.umd.cs.jazz.<A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../edu/umd/cs/jazz/ZNode.html#addClientProperty(edu.umd.cs.jazz.util.ZProperty)">addClientProperty</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#addMouseListener(edu.umd.cs.jazz.event.ZMouseListener)">addMouseListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#addMouseMotionListener(edu.umd.cs.jazz.event.ZMouseMotionListener)">addMouseMotionListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#addNodeListener(edu.umd.cs.jazz.event.ZNodeListener)">addNodeListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#editor()">editor</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#fireEvent(edu.umd.cs.jazz.event.ZNodeEvent, int, edu.umd.cs.jazz.ZNode)">fireEvent</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#fireMouseEvent(edu.umd.cs.jazz.event.ZMouseEvent)">fireMouseEvent</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#fireNodeEvent(int, edu.umd.cs.jazz.ZNode)">fireNodeEvent</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#getClientProperty(java.lang.Object)">getClientProperty</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#getGlobalBounds()">getGlobalBounds</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#getGlobalToLocalTransform()">getGlobalToLocalTransform</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#getParent()">getParent</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#getRoot()">getRoot</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#globalToLocal(java.awt.geom.Point2D)">globalToLocal</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#globalToLocal(java.awt.geom.Rectangle2D)">globalToLocal</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#hasMouseListener()">hasMouseListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#hasNodeListener()">hasNodeListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#isAncestorOf(edu.umd.cs.jazz.ZNode)">isAncestorOf</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#isDescendentOf(edu.umd.cs.jazz.ZNode)">isDescendentOf</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#isFindable()">isFindable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#isPickable()">isPickable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#isSavable()">isSavable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#localToGlobal(java.awt.geom.Point2D)">localToGlobal</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#localToGlobal(java.awt.geom.Rectangle2D)">localToGlobal</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#lower()">lower</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#lowerTo(edu.umd.cs.jazz.ZNode)">lowerTo</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#putClientProperty(java.lang.Object, java.lang.Object)">putClientProperty</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#raise()">raise</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#raiseTo(edu.umd.cs.jazz.ZNode)">raiseTo</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#remove()">remove</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#removeMouseListener(edu.umd.cs.jazz.event.ZMouseListener)">removeMouseListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#removeMouseMotionListener(edu.umd.cs.jazz.event.ZMouseMotionListener)">removeMouseMotionListener</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#repaint()">repaint</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#reparent(edu.umd.cs.jazz.ZGroup)">reparent</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#replaceWith(edu.umd.cs.jazz.ZNode)">replaceWith</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#setEditorFactory(edu.umd.cs.jazz.util.ZSceneGraphEditorFactory)">setEditorFactory</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#setFindable(boolean)">setFindable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#setParent(edu.umd.cs.jazz.ZGroup)">setParent</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#setPickable(boolean)">setPickable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#setSavable(boolean)">setSavable</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#updateBounds()">updateBounds</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#updateObjectReferences(edu.umd.cs.jazz.util.ZObjectReferenceTable)">updateObjectReferences</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZNode.html#writeReplace()">writeReplace</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_edu.umd.cs.jazz.ZSceneGraphObject"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class edu.umd.cs.jazz.<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html">ZSceneGraphObject</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#clone()">clone</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#getBounds()">getBounds</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#getBoundsReference()">getBoundsReference</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#reshape()">reshape</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#setBounds(edu.umd.cs.jazz.util.ZBounds)">setBounds</A>, 
<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#setVolatileBounds(boolean)">setVolatileBounds</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, 
finalize, 
getClass, 
hashCode, 
notify, 
notifyAll, 
toString, 
wait, 
wait, 
wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ZTransformGroup()"><!-- --></A><H3>
ZTransformGroup</H3>
<PRE>
public <B>ZTransformGroup</B>()</PRE>
<DL>
<DD>Constructs an empty ZTransformGroup.</DL>
<HR>

<A NAME="ZTransformGroup(edu.umd.cs.jazz.ZNode)"><!-- --></A><H3>
ZTransformGroup</H3>
<PRE>
public <B>ZTransformGroup</B>(<A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A>&nbsp;child)</PRE>
<DL>
<DD>Constructs a new transform group node with the specified node as a child of the
 new group.  If the specified child was already a member of a tree (i.e., had a parent),
 then this new node is inserted in the tree above the child so that the original
 child is still in that tree, but with this node inserted in the middle of the tree.
 If the specified child does not have a parent, then it is just made a child of this node.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>child</CODE> - Child of the new group node.</DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="duplicateObject()"><!-- --></A><H3>
duplicateObject</H3>
<PRE>
protected java.lang.Object <B>duplicateObject</B>()</PRE>
<DL>
<DD>Returns a clone of this object.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#duplicateObject()">duplicateObject</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html#duplicateObject()"><CODE>ZSceneGraphObject.duplicateObject()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="render(edu.umd.cs.jazz.util.ZRenderContext)"><!-- --></A><H3>
render</H3>
<PRE>
public void <B>render</B>(<A HREF="../../../../edu/umd/cs/jazz/util/ZRenderContext.html">ZRenderContext</A>&nbsp;renderContext)</PRE>
<DL>
<DD>Renders this node which results in its children getting painted.
 <p>
 The transform, clip, and composite will be set appropriately when this object
 is rendered.  It is up to this object to restore the transform, clip, and composite of
 the Graphics2D if this node changes any of them. However, the color, font, and stroke are
 unspecified by Jazz.  This object should set those things if they are used, but
 they do not need to be restored.
 <P>
 This transform node applies its transform before painting its children.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#render(edu.umd.cs.jazz.util.ZRenderContext)">render</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderContext</CODE> - The graphics context to use for rendering.</DL>
</DD>
</DL>
<HR>

<A NAME="computeBounds()"><!-- --></A><H3>
computeBounds</H3>
<PRE>
protected void <B>computeBounds</B>()</PRE>
<DL>
<DD>Recomputes and caches the bounds for this node.  Generally this method is
 called by reshape when the bounds have changed, and it should rarely
 directly elsewhere.  A ZTransformGroup bounds is the union
 of its children's bounds, transformed by this node's transform.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#computeBounds()">computeBounds</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
</DL>
<HR>

<A NAME="repaint(edu.umd.cs.jazz.util.ZBounds)"><!-- --></A><H3>
repaint</H3>
<PRE>
public void <B>repaint</B>(<A HREF="../../../../edu/umd/cs/jazz/util/ZBounds.html">ZBounds</A>&nbsp;repaintBounds)</PRE>
<DL>
<DD>Method to pass repaint methods up the tree.  Repaints only the sub-
 portion of this object specified by the given ZBounds.
 Note that the input parameter may be modified as a result of this call.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZNode.html#repaint(edu.umd.cs.jazz.util.ZBounds)">repaint</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>repaintBounds</CODE> - The bounds to repaint</DL>
</DD>
</DL>
<HR>

<A NAME="repaint(edu.umd.cs.jazz.ZSceneGraphObject, java.awt.geom.AffineTransform, edu.umd.cs.jazz.util.ZBounds)"><!-- --></A><H3>
repaint</H3>
<PRE>
public void <B>repaint</B>(<A HREF="../../../../edu/umd/cs/jazz/ZSceneGraphObject.html">ZSceneGraphObject</A>&nbsp;obj,
                    java.awt.geom.AffineTransform&nbsp;at,
                    <A HREF="../../../../edu/umd/cs/jazz/util/ZBounds.html">ZBounds</A>&nbsp;clipBounds)</PRE>
<DL>
<DD>Method to pass repaint methods up the tree.  Repaints only the sub-
 portion of this object specified by the given ZBounds.
 Note that the transform and clipBounds parameters may be modified as a result of this call.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZNode.html#repaint(edu.umd.cs.jazz.ZSceneGraphObject, java.awt.geom.AffineTransform, edu.umd.cs.jazz.util.ZBounds)">repaint</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - The object to repaint<DD><CODE>at</CODE> - The affine transform<DD><CODE>clipBounds</CODE> - The bounds to clip to when repainting</DL>
</DD>
</DL>
<HR>

<A NAME="pick(java.awt.geom.Rectangle2D, edu.umd.cs.jazz.util.ZSceneGraphPath)"><!-- --></A><H3>
pick</H3>
<PRE>
public boolean <B>pick</B>(java.awt.geom.Rectangle2D&nbsp;rect,
                    <A HREF="../../../../edu/umd/cs/jazz/util/ZSceneGraphPath.html">ZSceneGraphPath</A>&nbsp;path)</PRE>
<DL>
<DD>Returns the first object under the specified rectangle (if there is one)
 in the subtree rooted with this as searched in reverse (front-to-back) order.
 This performs a depth-first search, first picking children.
 Only returns a node if this is "pickable".<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#pick(java.awt.geom.Rectangle2D, edu.umd.cs.jazz.util.ZSceneGraphPath)">pick</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Coordinates of pick rectangle in local coordinates<DD><CODE>path</CODE> - The path through the scenegraph to the picked node. Modified by this call.<DT><B>Returns:</B><DD>The picked node, or null if none<DT><B>See Also: </B><DD><A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html#pick(int, int)"><CODE>ZDrawingSurface.pick(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTransformListener(edu.umd.cs.jazz.event.ZTransformListener)"><!-- --></A><H3>
addTransformListener</H3>
<PRE>
public void <B>addTransformListener</B>(<A HREF="../../../../edu/umd/cs/jazz/event/ZTransformListener.html">ZTransformListener</A>&nbsp;l)</PRE>
<DL>
<DD>Adds the specified transform listener to receive transform events from this node<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>l</CODE> - the transform listener</DL>
</DD>
</DL>
<HR>

<A NAME="removeTransformListener(edu.umd.cs.jazz.event.ZTransformListener)"><!-- --></A><H3>
removeTransformListener</H3>
<PRE>
public void <B>removeTransformListener</B>(<A HREF="../../../../edu/umd/cs/jazz/event/ZTransformListener.html">ZTransformListener</A>&nbsp;l)</PRE>
<DL>
<DD>Removes the specified transform listener so that it no longer
 receives transform events from this transform.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>l</CODE> - the transform listener</DL>
</DD>
</DL>
<HR>

<A NAME="fireTransformEvent(int, java.awt.geom.AffineTransform)"><!-- --></A><H3>
fireTransformEvent</H3>
<PRE>
protected void <B>fireTransformEvent</B>(int&nbsp;id,
                                  java.awt.geom.AffineTransform&nbsp;origTransform)</PRE>
<DL>
<DD>Notifies all listeners that have registered interest for
 notification on this event type.  The event instance
 is lazily created using the parameters passed into
 the fire method.  The listener list is processed in last to
 first order.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - The event id (TRANSFORM_CHANGED)<DD><CODE>origTransform</CODE> - The original transform (for transform events)<DT><B>See Also: </B><DD><CODE>EventListenerList</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getTransform()"><!-- --></A><H3>
getTransform</H3>
<PRE>
public java.awt.geom.AffineTransform <B>getTransform</B>()</PRE>
<DL>
<DD>Returns a copy of the transform that that this node specifies.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>The current transform.</DL>
</DD>
</DL>
<HR>

<A NAME="getMatrix(double[])"><!-- --></A><H3>
getMatrix</H3>
<PRE>
public void <B>getMatrix</B>(double[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>Retrieves the 6 specifiable values in the affine transformation,
 and places them into an array of double precisions values.
 The values are stored in the array as
 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;}.
 An array of 4 doubles can also be specified, in which case only the
 first four elements representing the non-transform
 parts of the array are retrieved and the values are stored into
 the array as {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;}<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html#getMatrix(double[])">getMatrix</A> in interface <A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flatmatrix</CODE> - the double array used to store the returned
 values.</DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(java.awt.geom.AffineTransform)"><!-- --></A><H3>
setTransform</H3>
<PRE>
public void <B>setTransform</B>(java.awt.geom.AffineTransform&nbsp;newTransform)</PRE>
<DL>
<DD>Sets the transform associated with this node.
 This transform applies to the sub-tree rooted at this node.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>newTransform</CODE> - &nbsp;</DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(double, double, double, double, double, double)"><!-- --></A><H3>
setTransform</H3>
<PRE>
public void <B>setTransform</B>(double&nbsp;m00,
                         double&nbsp;m10,
                         double&nbsp;m01,
                         double&nbsp;m11,
                         double&nbsp;m02,
                         double&nbsp;m12)</PRE>
<DL>
<DD>Sets the transform associated with this node.
 This transform applies to the sub-tree rooted at this node.<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html#setTransform(double, double, double, double, double, double)">setTransform</A> in interface <A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>m00,&nbsp;m01,&nbsp;m02,&nbsp;m10,&nbsp;m11,&nbsp;m12</CODE> - the
 6 values that compose the 3x3 transformation matrix</DL>
</DD>
</DL>
<HR>

<A NAME="concatenate(java.awt.geom.AffineTransform)"><!-- --></A><H3>
concatenate</H3>
<PRE>
public void <B>concatenate</B>(java.awt.geom.AffineTransform&nbsp;at)</PRE>
<DL>
<DD>Concatenates an AffineTransform <code>at</code> to this node's transform in
 the standard way.  This has the affect of applying <code>at</code> in this
 node's local coordinate system.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>at</CODE> - The transform to concatenate<DT><B>See Also: </B><DD><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#preConcatenate(java.awt.geom.AffineTransform)"><CODE>preConcatenate(java.awt.geom.AffineTransform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="preConcatenate(java.awt.geom.AffineTransform)"><!-- --></A><H3>
preConcatenate</H3>
<PRE>
public void <B>preConcatenate</B>(java.awt.geom.AffineTransform&nbsp;at)</PRE>
<DL>
<DD>Pre-Concatenates an AffineTransform <code>at</code> to this node's transform in a less commonly
 used way such that <code>at</code> gets pre-multipled with the existing transform rather
 than the more normal post-multiplication.  This has the affect of applying the transform <code>at</code>
 in the coordinate system above this node, rather than within the local coordinate system
 of this node.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>at</CODE> - The transform to pre-concatenate<DT><B>See Also: </B><DD><A HREF="../../../../edu/umd/cs/jazz/ZTransformGroup.html#concatenate(java.awt.geom.AffineTransform)"><CODE>concatenate(java.awt.geom.AffineTransform)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLocalToGlobalTransform()"><!-- --></A><H3>
getLocalToGlobalTransform</H3>
<PRE>
public java.awt.geom.AffineTransform <B>getLocalToGlobalTransform</B>()</PRE>
<DL>
<DD>Return the transform that converts local coordinates at this node to global coordinates
 at the root node.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZNode.html#getLocalToGlobalTransform()">getLocalToGlobalTransform</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>The concatenation of transforms from the root down to this node.</DL>
</DD>
</DL>
<HR>

<A NAME="computeInverseTransform()"><!-- --></A><H3>
computeInverseTransform</H3>
<PRE>
protected void <B>computeInverseTransform</B>()</PRE>
<DL>
<DD>Internal method to compute the inverse transform based on the transform.
 This gets called from within ZTransformGroup
 whenever the inverse transform cache has been invalidated,
 and it is needed.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInverseTransform()"><!-- --></A><H3>
getInverseTransform</H3>
<PRE>
public java.awt.geom.AffineTransform <B>getInverseTransform</B>()</PRE>
<DL>
<DD>Returns the inverse of the transform associated with this node.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>The current inverse transform.</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslation()"><!-- --></A><H3>
getTranslation</H3>
<PRE>
public java.awt.geom.Point2D <B>getTranslation</B>()</PRE>
<DL>
<DD>Returns the current translation of this node<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateX()"><!-- --></A><H3>
getTranslateX</H3>
<PRE>
public double <B>getTranslateX</B>()</PRE>
<DL>
<DD>Returns the current X translation of this node<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="setTranslateX(double)"><!-- --></A><H3>
setTranslateX</H3>
<PRE>
public void <B>setTranslateX</B>(double&nbsp;x)</PRE>
<DL>
<DD>Sets the current X translation of this node<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateY()"><!-- --></A><H3>
getTranslateY</H3>
<PRE>
public double <B>getTranslateY</B>()</PRE>
<DL>
<DD>Returns the current Y translation of this node<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="setTranslateY(double)"><!-- --></A><H3>
setTranslateY</H3>
<PRE>
public void <B>setTranslateY</B>(double&nbsp;y)</PRE>
<DL>
<DD>Sets the current Y translation of this node<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="translate(double, double)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(double&nbsp;dx,
                      double&nbsp;dy)</PRE>
<DL>
<DD>Translate the node by the specified deltaX and deltaY<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dx</CODE> - X-coord of translation<DD><CODE>dy</CODE> - Y-coord of translation</DL>
</DD>
</DL>
<HR>

<A NAME="translate(double, double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(double&nbsp;dx,
                      double&nbsp;dy,
                      int&nbsp;millis,
                      <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the node from its current position by the specified deltaX and deltaY<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dx</CODE> - X-coord of translation<DD><CODE>dy</CODE> - Y-coord of translation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="setTranslation(double, double)"><!-- --></A><H3>
setTranslation</H3>
<PRE>
public void <B>setTranslation</B>(double&nbsp;x,
                           double&nbsp;y)</PRE>
<DL>
<DD>Translate the node to the specified position<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X-coord of translation<DD><CODE>y</CODE> - Y-coord of translation</DL>
</DD>
</DL>
<HR>

<A NAME="setTranslation(double, double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
setTranslation</H3>
<PRE>
public void <B>setTranslation</B>(double&nbsp;x,
                           double&nbsp;y,
                           int&nbsp;millis,
                           <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the node from its current position to the position specified
 by x, y<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X-coord of translation<DD><CODE>y</CODE> - Y-coord of translation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="getScale()"><!-- --></A><H3>
getScale</H3>
<PRE>
public double <B>getScale</B>()</PRE>
<DL>
<DD>Returns the current scale of this transform.
 Note that this is implemented by applying the transform to a diagonal
 line and returning the length of the resulting line.  If the transform
 is sheared, or has a non-uniform scaling in X and Y, the results of
 this method will be ill-defined.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the scale</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(double&nbsp;dz)</PRE>
<DL>
<DD>Scale the node from its current scale to the scale specified
 by muliplying the current scale and dz.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, double, double)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(double&nbsp;dz,
                  double&nbsp;x,
                  double&nbsp;y)</PRE>
<DL>
<DD>Scale the node around the specified point (x, y)
 from its current scale to the scale specified
 by muliplying the current scale and dz.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(double&nbsp;dz,
                  int&nbsp;millis,
                  <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the node from its current scale to the scale specified
 by muliplying the current scale and deltaZ<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(double&nbsp;dz,
                  double&nbsp;x,
                  double&nbsp;y,
                  int&nbsp;millis,
                  <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the node around the specified point (x, y)
 from its current scale to the scale specified
 by muliplying the current scale and dz<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="setScale(double)"><!-- --></A><H3>
setScale</H3>
<PRE>
public void <B>setScale</B>(double&nbsp;finalz)</PRE>
<DL>
<DD>Sets the scale of the transform<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>the</CODE> - new scale</DL>
</DD>
</DL>
<HR>

<A NAME="setScale(double, double, double)"><!-- --></A><H3>
setScale</H3>
<PRE>
public void <B>setScale</B>(double&nbsp;finalz,
                     double&nbsp;x,
                     double&nbsp;y)</PRE>
<DL>
<DD>Set the scale of the node to the specified target scale,
 scaling the node around the specified point (x, y).<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>finalz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around</DL>
</DD>
</DL>
<HR>

<A NAME="setScale(double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
setScale</H3>
<PRE>
public void <B>setScale</B>(double&nbsp;finalz,
                     int&nbsp;millis,
                     <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the node from its current scale to the specified target scale.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>finalz</CODE> - scale factor<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="setScale(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
setScale</H3>
<PRE>
public void <B>setScale</B>(double&nbsp;finalz,
                     double&nbsp;x,
                     double&nbsp;y,
                     int&nbsp;millis,
                     <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Animate the node around the specified point (x, y)
 to the specified target scale.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>finalz</CODE> - scale factor<DD><CODE>x</CODE> - X coordinate of the point to scale around<DD><CODE>y</CODE> - Y coordinate of the point to scale around<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="getRotation()"><!-- --></A><H3>
getRotation</H3>
<PRE>
public double <B>getRotation</B>()</PRE>
<DL>
<DD>Returns the current rotation of this node<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the rotation angle in radians.</DL>
</DD>
</DL>
<HR>

<A NAME="setRotation(double)"><!-- --></A><H3>
setRotation</H3>
<PRE>
public void <B>setRotation</B>(double&nbsp;theta)</PRE>
<DL>
<DD>Set the absolute rotation of this node.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)</DL>
</DD>
</DL>
<HR>

<A NAME="setRotation(double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
setRotation</H3>
<PRE>
public void <B>setRotation</B>(double&nbsp;theta,
                        int&nbsp;millis,
                        <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Set the absolute rotation of this node, animating the change over time.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>millis</CODE> - Time to animate scale in milliseconds<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="setRotation(double, double, double)"><!-- --></A><H3>
setRotation</H3>
<PRE>
public void <B>setRotation</B>(double&nbsp;theta,
                        double&nbsp;xctr,
                        double&nbsp;yctr)</PRE>
<DL>
<DD>Set the absolute rotation of this node, rotating around the specified anchor point.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>xctr</CODE> - X-coord of anchor point<DD><CODE>yctr</CODE> - Y-coord of anchor point</DL>
</DD>
</DL>
<HR>

<A NAME="setRotation(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
setRotation</H3>
<PRE>
public void <B>setRotation</B>(double&nbsp;theta,
                        double&nbsp;xctr,
                        double&nbsp;yctr,
                        int&nbsp;millis,
                        <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Set the absolute rotation of this node, via animation, theta radians about the specified anchor point.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>xctr</CODE> - X-coord of anchor point<DD><CODE>yctr</CODE> - Y-coord of anchor point<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta)</PRE>
<DL>
<DD>Rotate the node by the specified amount<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta,
                   double&nbsp;xctr,
                   double&nbsp;yctr)</PRE>
<DL>
<DD>Rotate the node by the specified amount around the specified anchor point<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>xctr</CODE> - X-coord of anchor point<DD><CODE>yctr</CODE> - Y-coord of anchor point</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta,
                   int&nbsp;millis,
                   <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Rotate the node, via animation, theta radians<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>millis</CODE> - Time to animate scale in milliseconds<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta,
                   double&nbsp;xctr,
                   double&nbsp;yctr,
                   int&nbsp;millis,
                   <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Rotate the node, via animation, theta radians about the specified anchor point<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>theta</CODE> - angle to rotate (in radians)<DD><CODE>xctr</CODE> - X-coord of anchor point<DD><CODE>yctr</CODE> - Y-coord of anchor point<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="position(java.awt.geom.Point2D, java.awt.geom.Point2D, edu.umd.cs.jazz.ZNode, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
position</H3>
<PRE>
public void <B>position</B>(java.awt.geom.Point2D&nbsp;srcPt,
                     java.awt.geom.Point2D&nbsp;destPt,
                     <A HREF="../../../../edu/umd/cs/jazz/ZNode.html">ZNode</A>&nbsp;refNode,
                     int&nbsp;millis,
                     <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>This will calculate the necessary transform in order to make this
 node appear at a particular position relative to the
 specified node.  The source point specifies a point in the
 unit square (0, 0) - (1, 1) that represents an anchor point on the
 corresponding node to this transform.  The destination point specifies
 an anchor point on the reference node.  The position method then
 computes the transform that results in transforming this node so that
 the source anchor point coincides with the reference anchor
 point. This can be useful for layout algorithms as it is
 straightforward to position one object relative to another.
 <p>
 For example, If you have two nodes, A and B, and you call
 <PRE>
     Point2D srcPt = new Point2D.Double(1.0, 0.0);
     Point2D destPt = new Point2D.Double(0.0, 0.0);
     A.position(srcPt, destPt, B, 750, null);
 </PRE>
 The result is that A will move so that its upper-right corner is at
 the same place as the upper-left corner of B, and the transition will
 be smoothly animated over a period of 750 milliseconds.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srcPt</CODE> - The anchor point on this transform's node (normalized to a unit square)<DD><CODE>destPt</CODE> - The anchor point on destination bounds (normalized to a unit square)<DD><CODE>destBounds</CODE> - The bounds used to calculate this transform's node<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to be updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="position(java.awt.geom.Point2D, java.awt.geom.Point2D, java.awt.geom.Rectangle2D, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
position</H3>
<PRE>
public void <B>position</B>(java.awt.geom.Point2D&nbsp;srcPt,
                     java.awt.geom.Point2D&nbsp;destPt,
                     java.awt.geom.Rectangle2D&nbsp;destBounds,
                     int&nbsp;millis,
                     <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>This will calculate the necessary transform in order to make this
 node appear at a particular position relative to the
 specified bounding box.  The source point specifies a point in the
 unit square (0, 0) - (1, 1) that represents an anchor point on the
 corresponding node to this transform.  The destination point specifies
 an anchor point on the reference node.  The position method then
 computes the transform that results in transforming this node so that
 the source anchor point coincides with the reference anchor
 point. This can be useful for layout algorithms as it is
 straightforward to position one object relative to another.
 <p>
 For example, If you have two nodes, A and B, and you call
 <PRE>
     Point2D srcPt = new Point2D.Double(1.0, 0.0);
     Point2D destPt = new Point2D.Double(0.0, 0.0);
     A.position(srcPt, destPt, B.getGlobalBounds(), 750, null);
 </PRE>
 The result is that A will move so that its upper-right corner is at
 the same place as the upper-left corner of B, and the transition will
 be smoothly animated over a period of 750 milliseconds.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srcPt</CODE> - The anchor point on this transform's node (normalized to a unit square)<DD><CODE>destPt</CODE> - The anchor point on destination bounds (normalized to a unit square)<DD><CODE>destBounds</CODE> - The bounds (in global coordinates) used to calculate this transform's node<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="computeScale(java.awt.geom.AffineTransform)"><!-- --></A><H3>
computeScale</H3>
<PRE>
public static double <B>computeScale</B>(java.awt.geom.AffineTransform&nbsp;at)</PRE>
<DL>
<DD>Given an AffineTransform, this returns the
 "scale" of the transform. The scale of an affine transform
 is computed by transforming a vector and seeing how its length changes.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lerp(double, double, double)"><!-- --></A><H3>
lerp</H3>
<PRE>
public static double <B>lerp</B>(double&nbsp;t,
                          double&nbsp;a,
                          double&nbsp;b)</PRE>
<DL>
<DD>Linearly interpolates between a and b, based on t.
 Specifically, it computes lerp(a, b, t) = a + t*(b - a).
 This produces a result that changes from a (when t = 0) to b (when t = 1).<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - from point<DD><CODE>b</CODE> - to Point<DD><CODE>t</CODE> - variable 'time' parameter</DL>
</DD>
</DL>
<HR>

<A NAME="transform(edu.umd.cs.jazz.util.ZBounds, java.awt.geom.AffineTransform)"><!-- --></A><H3>
transform</H3>
<PRE>
public static void <B>transform</B>(<A HREF="../../../../edu/umd/cs/jazz/util/ZBounds.html">ZBounds</A>&nbsp;bounds,
                             java.awt.geom.AffineTransform&nbsp;at)</PRE>
<DL>
<DD>Apply the specified transform to the specified bounds, modifying the bounds.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bounds</CODE> - The bounds to be transformed<DD><CODE>at</CODE> - The transform to use to transform the rectangle</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Rectangle2D, java.awt.geom.AffineTransform)"><!-- --></A><H3>
transform</H3>
<PRE>
public static void <B>transform</B>(java.awt.geom.Rectangle2D&nbsp;rect,
                             java.awt.geom.AffineTransform&nbsp;at)</PRE>
<DL>
<DD>Apply the specified transform to the specified rectangle, modifying the rect.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - The rectangle to be transformed<DD><CODE>at</CODE> - The transform to use to transform the rectangle</DL>
</DD>
</DL>
<HR>

<A NAME="animate(edu.umd.cs.jazz.ZTransformable, java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
animate</H3>
<PRE>
public static void <B>animate</B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>&nbsp;node,
                           java.awt.geom.AffineTransform&nbsp;tx,
                           int&nbsp;millis,
                           <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Set the transform of the specified node to the specified transform,
 and animate the change from its current transformation over the specified
 number of milliseconds using a slow-in slow-out animation.
 The surface specifies which surface should be updated during the animation.
 Note that another version of animate lets you specify the timing of
 the animation so you can avoid the slow-in slow-out animation if you prefer.
 <p>
 If millis is 0, then the transform is updated once, and the scene
 is not repainted immediately, but rather a repaint request is queued,
 and will be processed by an event handler.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - The node to be animated<DD><CODE>tx</CODE> - Final transformation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="animate(edu.umd.cs.jazz.ZTransformable, java.awt.geom.AffineTransform, int, edu.umd.cs.jazz.ZDrawingSurface, edu.umd.cs.jazz.util.ZLerp)"><!-- --></A><H3>
animate</H3>
<PRE>
public static void <B>animate</B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>&nbsp;node,
                           java.awt.geom.AffineTransform&nbsp;at,
                           int&nbsp;millis,
                           <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface,
                           <A HREF="../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</PRE>
<DL>
<DD>Set the transform of the specified node to the specified transform,
 and animate the change from its current transformation over the specified
 number of milliseconds using a slow-in slow-out animation.
 The surface specifies which surface should be updated during the animation.
 Note that another version of animate lets you specify the timing of
 the animation so you can avoid the slow-in slow-out animation if you prefer.
 <p>
 If millis is 0, then the transform is updated once, and the scene
 is not repainted immediately, but rather a repaint request is queued,
 and will be processed by an event handler.
 <p>
 The timing of the animation is controlled by the <tt>lerpTimeFunction</tt>.
 This is used to specify the rate the animation occurs over time.  If this
 parameter is specified as null, then a standard linear interpolation is
 used, and the animation goes at a constant speed from beginning to end.
 The caller can specify alternate functions, however, which can do things
 like perform a slow-in, slow-out animation.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>node</CODE> - The node to be animated<DD><CODE>at</CODE> - Final transformation<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.<DD><CODE>lerpTimeFunction</CODE> - The function that determines how the timing of the animation should be calculated</DL>
</DD>
</DL>
<HR>

<A NAME="animate(edu.umd.cs.jazz.ZTransformable[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.ZDrawingSurface)"><!-- --></A><H3>
animate</H3>
<PRE>
public static void <B>animate</B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>[]&nbsp;nodes,
                           java.awt.geom.AffineTransform[]&nbsp;txs,
                           int&nbsp;millis,
                           <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface)</PRE>
<DL>
<DD>Set the transforms of the specified array of nodes to the specified
 array of transforms,
 and animate the change over the specified
 number of milliseconds using a slow-in slow-out animation.
 The surface specifies which surface should be updated during the animation.
 (Note that another version of animate lets you specify the timing of
 the animation so you can avoid the slow-in slow-out animation if you prefer.)
 <p>
 If the size of the nodes and txs arrays are not equal, then only those
 nodes for which transforms are specified will be animated.  That is,
 the smaller of the two array sizes will be used.
 <p>
 If millis is 0, then the transform is updated once, and the scene
 is not repainted immediately, but rather a repaint request is queued,
 and will be processed by an event handler.
 <p>
 The following code fragment demonstrates the use of this animate
 method.  It creates three rectangles, and animates two of them
 simultaneously.
 <pre>
     ZRectangle rect1, rect2, rect3;
     ZVisualLeaf leaf1, leaf2, leaf3;
     ZTransformable node1, node2, node3;

     rect1 = new ZRectangle(0, 0, 50, 50);
     rect1.setFillColor(Color.red);
     leaf1 = new ZVisualLeaf(rect1);
     node1 = new ZTransformable();
     node1.addChild(leaf1);
     layer.addChild(node1);

     rect2 = new ZRectangle(25, 25, 50, 50);
     rect2.setFillColor(Color.blue);
     leaf2 = new ZVisualLeaf(rect2);
     node2 = new ZNode();
     node2.addChild(leaf2);
     layer.addChild(node2);

     rect3 = new ZRectangle(100, 100, 50, 50);
     rect3.setFillColor(Color.orange);
     leaf3 = new ZVisualLeaf(rect3);
     node3 = new ZNode(rect3);
     node3.addChild(leaf3);
     layer.addChild(node3);

     ZTransformable[] nodes = new ZTransformable[2];
     nodes[0] = node1;
     nodes[1] = node2;
     AffineTransform[] txs = new AffineTransform[2];
     txs[0] = new AffineTransform();
     txs[0].scale(2.0, 2.0);
     txs[1] = new AffineTransform();
     txs[1].translate(100.0, 25.0);
     txs[1].scale(0.5, 0.5);

     ZTransform.animate(nodes, txs, 1000, surface);
 </pre><DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodes</CODE> - The array of nodes to be animated<DD><CODE>txs</CODE> - The array of final transformations of the nodes<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.</DL>
</DD>
</DL>
<HR>

<A NAME="animate(edu.umd.cs.jazz.ZTransformable[], java.awt.geom.AffineTransform[], int, edu.umd.cs.jazz.ZDrawingSurface, edu.umd.cs.jazz.util.ZLerp)"><!-- --></A><H3>
animate</H3>
<PRE>
public static void <B>animate</B>(<A HREF="../../../../edu/umd/cs/jazz/ZTransformable.html">ZTransformable</A>[]&nbsp;nodes,
                           java.awt.geom.AffineTransform[]&nbsp;txs,
                           int&nbsp;millis,
                           <A HREF="../../../../edu/umd/cs/jazz/ZDrawingSurface.html">ZDrawingSurface</A>&nbsp;surface,
                           <A HREF="../../../../edu/umd/cs/jazz/util/ZLerp.html">ZLerp</A>&nbsp;lerpTimeFunction)</PRE>
<DL>
<DD>Set the transforms of the specified array of nodes to the specified
 array of transforms,
 and animate the change over the specified
 number of milliseconds using a slow-in slow-out animation.
 The surface specifies which surface should be updated during the animation.
 (Note that another version of animate lets you specify the timing of
 the animation so you can avoid the slow-in slow-out animation if you prefer.)
 <p>
 If the size of the nodes and txs arrays are not equal, then only those
 nodes for which transforms are specified will be animated.  That is,
 the smaller of the two array sizes will be used.
 <p>
 If millis is 0, then the transform is updated once, and the scene
 is not repainted immediately, but rather a repaint request is queued,
 and will be processed by an event handler.
 <p>
 The timing of the animation is controlled by the <tt>lerpTimeFunction</tt>.
 This is used to specify the rate the animation occurs over time.  If this
 parameter is specified as null, then a standard linear interpolation is
 used, and the animation goes at a constant speed from beginning to end.
 The caller can specify alternate functions, however, which can do things
 like perform a slow-in, slow-out animation.
 <p>
 The following code fragment demonstrates the use of this animate
 method.  It creates three rectangles, and animates two of them
 simultaneously.
 <pre>
     ZRectangle rect1, rect2, rect3;
     ZVisualLeaf leaf1, leaf2, leaf3;
     ZTransformable node1, node2, node3;

     rect1 = new ZRectangle(0, 0, 50, 50);
     rect1.setFillColor(Color.red);
     leaf1 = new ZVisualLeaf(rect1);
     node1 = new ZTransformable();
     node1.addChild(leaf1);
     layer.addChild(node1);

     rect2 = new ZRectangle(25, 25, 50, 50);
     rect2.setFillColor(Color.blue);
     leaf2 = new ZVisualLeaf(rect2);
     node2 = new ZNode();
     node2.addChild(leaf2);
     layer.addChild(node2);

     rect3 = new ZRectangle(100, 100, 50, 50);
     rect3.setFillColor(Color.orange);
     leaf3 = new ZVisualLeaf(rect3);
     node3 = new ZNode(rect3);
     node3.addChild(leaf3);
     layer.addChild(node3);

     ZTransformable[] nodes = new ZTransformable[2];
     nodes[0] = node1;
     nodes[1] = node2;
     AffineTransform[] txs = new AffineTransform[2];
     txs[0] = new AffineTransform();
     txs[0].scale(2.0, 2.0);
     txs[1] = new AffineTransform();
     txs[1].translate(100.0, 25.0);
     txs[1].scale(0.5, 0.5);

     ZTransform.animate(nodes, txs, 1000, surface);
 </pre><DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodes</CODE> - The array of nodes to be animated<DD><CODE>txs</CODE> - The array of final transformations of the nodes<DD><CODE>millis</CODE> - Number of milliseconds over which to perform the animation<DD><CODE>surface</CODE> - The surface to updated during animation.<DD><CODE>lerpTimeFunction</CODE> - The function that determines how the timing of the animation should be calculated</DL>
</DD>
</DL>
<HR>

<A NAME="dump()"><!-- --></A><H3>
dump</H3>
<PRE>
public java.lang.String <B>dump</B>()</PRE>
<DL>
<DD>Generate a string that represents this object for debugging.<DD><DL>
<DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#dump()">dump</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the string that represents this object for debugging<DT><B>See Also: </B><DD><A HREF="../../../../edu/umd/cs/jazz/util/ZDebug.html#dump(edu.umd.cs.jazz.ZNode)"><CODE>ZDebug.dump(edu.umd.cs.jazz.ZNode)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="writeObject(edu.umd.cs.jazz.io.ZObjectOutputStream)"><!-- --></A><H3>
writeObject</H3>
<PRE>
public void <B>writeObject</B>(<A HREF="../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)
                 throws java.io.IOException</PRE>
<DL>
<DD>Write out all of this object's state.<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html#writeObject(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObject</A> in interface <A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A><DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#writeObject(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObject</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - The stream that this object writes into</DL>
</DD>
</DL>
<HR>

<A NAME="writeObjectRecurse(edu.umd.cs.jazz.io.ZObjectOutputStream)"><!-- --></A><H3>
writeObjectRecurse</H3>
<PRE>
public void <B>writeObjectRecurse</B>(<A HREF="../../../../edu/umd/cs/jazz/io/ZObjectOutputStream.html">ZObjectOutputStream</A>&nbsp;out)
                        throws java.io.IOException</PRE>
<DL>
<DD>Specify which objects this object references in order to write out the scenegraph properly<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html#writeObjectRecurse(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObjectRecurse</A> in interface <A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A><DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#writeObjectRecurse(edu.umd.cs.jazz.io.ZObjectOutputStream)">writeObjectRecurse</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - The stream that this object writes into</DL>
</DD>
</DL>
<HR>

<A NAME="setState(java.lang.String, java.lang.String, java.lang.Object)"><!-- --></A><H3>
setState</H3>
<PRE>
public void <B>setState</B>(java.lang.String&nbsp;fieldType,
                     java.lang.String&nbsp;fieldName,
                     java.lang.Object&nbsp;fieldValue)</PRE>
<DL>
<DD>Set some state of this object as it gets read back in.
 After the object is created with its default no-arg constructor,
 this method will be called on the object once for each bit of state
 that was written out through calls to ZObjectOutputStream.writeState()
 within the writeObject method.<DD><DL>
<DT><B>Specified by: </B><DD><A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html#setState(java.lang.String, java.lang.String, java.lang.Object)">setState</A> in interface <A HREF="../../../../edu/umd/cs/jazz/io/ZSerializable.html">ZSerializable</A><DT><B>Overrides:</B><DD><A HREF="../../../../edu/umd/cs/jazz/ZGroup.html#setState(java.lang.String, java.lang.String, java.lang.Object)">setState</A> in class <A HREF="../../../../edu/umd/cs/jazz/ZGroup.html">ZGroup</A></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fieldType</CODE> - The fully qualified type of the field<DD><CODE>fieldName</CODE> - The name of the field<DD><CODE>fieldValue</CODE> - The value of the field</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ZTransformGroup.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Jazz API Documentation</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../edu/umd/cs/jazz/ZStickyGroup.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../edu/umd/cs/jazz/ZTreeLayoutManager.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ZTransformGroup.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_edu.umd.cs.jazz.ZGroup">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
