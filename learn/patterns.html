<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta name='generator'
    content='HTML Tidy for Linux/x86 (vers 1st December 2002), see www.w3.org' />
    <meta content='text/html; charset=us-ascii' http-equiv='Content-Type' />
    <meta name='description' content='Home Page for the Piccolo2D project.' />
    <meta name='format' content='text/html' />
    <meta name='keywords'
    content='piccolo2d, piccolo2d.net, piccolo, piccolo.net, zoomable, zui, user interfaces, human-computer interaction, HCI, visualization, education' />
    <meta name='relation' content='(contained in)=http://www.piccolo2d.org' />
    <title>
      Piccolo2D - Pattern
    </title>
    <link href='../piccolo2d.css' rel='stylesheet' type='text/css' />
    <script type='text/javascript' src='snippets.js'>
    //<![CDATA[
    //]]>
    </script>
    <script type='text/javascript' src='../scrollsidebar.js'>
    //<![CDATA[
    //]]>
    </script>
  </head>
  <body>
    <div id='navigation'>
      <!-- 
      this navigation node is auto-generated and injected
      by the script tools/inject_navigation.rb

      DO NOT EDIT IT MANUALLY!!!      
      -->
      <p>
        <a href='../index.html'><img src='../images/Piccolo2D-Logo-small.png'
        alt='Piccolo2D Logo' /></a>
      </p>
      <ul>
        <li>
          <a href='../index.html'>Piccolo2D&nbsp;Home</a>
          <ul>
            <li>
              <a href='../play/index.html'>Play</a>
            </li>
            <li>
              <a href='../learn/index.html'>Learn</a>
              <ul>
                <li>
                  <a href='../learn/about.html'>About&nbsp;Piccolo2D</a>
                </li>
                <li>
                  <a href='../learn/patterns.html' class='selected'>Piccolo2D&nbsp;Patterns</a>
                  <ul>
                    <li>
                      <a href='#Intro'>Intro</a>
                      <ul>
                        <li>
                          <a href='#ZUIs'>ZUIs</a>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <a href='#Usage_Patterns'>Usage</a>
                      <ul>
                        <li>
                          <a href='#Building_Piccolo2D'>Build</a>
                        </li>
                        <li>
                          <a href='#Creating_Nodes'>Creating&nbsp;Nodes</a>
                        </li>
                        <li>
                          <a href='#Adding_User_Interaction'>Adding&nbsp;Interaction</a>
                        </li>
                        <li>
                          <a href='#Layout_Constraints'>Layout&nbsp;Constraints</a>
                        </li>
                        <li>
                          <a href='#Activities'>Activities</a>
                        </li>
                        <li>
                          <a href='#SWT'>SWT</a>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <a href='#Implementation_Patterns_for_Piccolo2D'>Implementation</a>
                      <ul>
                        <li>
                          <a href='#Piccolo2D_Framework_Design'>Framework&nbsp;Design</a>
                        </li>
                        <li>
                          <a href='#Full_Terminology'>Full&nbsp;Terminology</a>
                        </li>
                        <li>
                          <a href='#Coordinate_Systems'>Coordinates</a>
                        </li>
                        <li>
                          <a href='#UI_Cycle'>UI&nbsp;Cycle</a>
                        </li>
                        <li>
                          <a href='#Threads'>Threads</a>
                        </li>
                        <li>
                          <a href='#Dispatching_Events'>Dispatching&nbsp;Events</a>
                        </li>
                        <li>
                          <a href='#Processing_Activities'>Processing&nbsp;Activities</a>
                        </li>
                        <li>
                          <a href='#Validating_Bounds'>Validating&nbsp;Bounds</a>
                        </li>
                        <li>
                          <a href='#Updating_the_Display'>Updating&nbsp;Display</a>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <a href='#Desing_Patterns_for_ZUI_Interfaces'>ZUI&nbsp;Design</a>
                      <ul>
                        <li>
                          <a href='#Semantic_Zooming'>Semantic&nbsp;Zooming</a>
                        </li>
                        <li>
                          <a href='#Sticky_Objects'>Sticky&nbsp;Objects</a>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href='../learn/get-started.html'>Getting&nbsp;Started</a>
                </li>
                <li>
                  <a href='../learn/api.html'>API&nbsp;Documentation</a>
                </li>
                <li>
                  <a href='../learn/comparison.html'>Piccolo2D&nbsp;in&nbsp;Comparison</a>
                </li>
                <li>
                  <a href='../learn/publications.html'>Publications</a>
                </li>
                <li>
                  <a href='../learn/dev-faq.html'>Developer&nbsp;FAQ</a>
                </li>
                <li>
                  <a href='../learn/graphics.html'>Graphics&nbsp;Primer</a>
                </li>
              </ul>
            </li>
            <li>
              <a href='../download.html'>Download</a>
            </li>
            <li>
              <a href='../community.html'>Community</a>
            </li>
            <li>
              <a href='../applications/index.html'>Applications</a>
            </li>
            <li>
              <a href='../press.html'>Press</a>
            </li>
            <li>
              <a href='../sponsors.html'>Sponsors</a>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        <img src='../images/giny-small.png' alt='a nice graph' />
      </p>
      <p>
        <a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10-blue'
             alt='Valid XHTML 1.0!' style='border:0;width:88px;height:31px' /></a>
             <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://www.w3.org/Icons/valid-css-blue'
             alt='Valid CSS1!' style='border:0;width:88px;height:31px' /></a>
      </p>
      <p class='bugreport'>
        <a href='http://code.google.com/p/piccolo2d/issues/entry?template=User%20defect%20report'>I
        found an error!</a>
      </p>
    </div>
    <div id='main'>
      <div id='main-head'>
        <h1>
          Piccolo2D Patterns
        </h1>Below, we explain the common programming Paradigms associated with Piccolo2D. This
        work is based heavily on the work of R. Johnson in his seminal 1992 paper "Documenting
        Frameworks using Patterns" and the work of Douglas Kirk in his <em>Patterns for
        JHotDraw</em> paper. This work merely attempts to adapt the concepts presented there into a
        format suitable for our Piccolo2D framework.
      </div>
      <p class='toggle' id='language'
      style='float: right; width: 8.5em; height: 8ex; border:thin solid blue;'>
        Show examples in<br />
         <img src='images/check.png' id='java13' alt='Checkmark'
        style='border:0;width:1.0em;height:2ex' /> <a href='javascript:void(0);'
        class='toggle selected' id='jlink13'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a><br />
         <img src='images/check.png' id='csharp13' alt='Checkmark'
        style='visibility: hidden;border:0;width:1.0em;height:2ex' /> <a href='javascript:void(0);'
        id='clink13'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <h2 id='Intro'>
        Intro
      </h2>
      <h3 id='ZUIs'>
        Pattern 1: Zoomable User Interfaces (ZUI's)
      </h3>
      <p class='preamble'>
        Piccolo2D is a framework for building zoomable user interfaces. The elements of these
        interfaces can be scaled or animated, and react to user input. The user viewpoint may also
        be scaled and panned. Interfaces built with Piccolo2D can define your entire application
        interface, or they can be a small part of a large system.
      </p>
      <p class='image'>
        <img src='../images/zoomsequence.jpg' alt='Zoom Sequence' />
      </p>
      <p>
        Figure 1 shows a sequence of frames from a simple zooming interface created using
        Piccolo2D. This example shows the fundamental aspects of a Piccolo2D application. In this
        sequence the user is zooming in on a "Hello world!" interface object.
      </p>
      <p>
        The objects on a piccolo2d canvas are nodes (instances of <code>PNode</code>), in this case
        a <code>PText</code> node. Nodes are used to represent the discrete components of an
        interface. The framework comes with some commonly required nodes (shapes, images, and text)
        and the developer has the opportunity to define new ones for their own interfaces.
      </p>
      <p>
        Figure 1's zooming interaction was created with the help of an event listener (instances of
        <code>PInputEventListener</code>). Event listeners define how the interface reacts to user
        input. In this zooming interaction the event listener reacted to mouse input by
        manipulating the camera node's view transform to create the zooming effect. Piccolo2D comes
        with ready-made event listeners for zooming and panning camera nodes, and dragging nodes on
        the canvas.
      </p>
      <p>
        All Piccolo2D interfaces need to be placed in a <code>PCanvas</code> so that they may be
        viewed and interacted with by the user. <code>PCanvas</code> extends the
        <code>javax.swing.JComponent</code> class in Piccolo2D.Java and the equivalent
        <code>System.Windows.Forms.Control</code> class in Piccolo2D.NET.&nbsp; As a result,
        piccolo2d can easily be integrated with both Java Swing and Windows applications. In
        addition to hosting Piccolo2D in the application interface, the canvas also maintains a
        camera and layer node. Scaling and translating the camera's view transform over time is how
        zooming and panning is accomplished. New nodes are normally added to the canvas's layer
        node.
      </p>
      <p>
        The interface depicted in figure 1 can be created with the following code:
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink0'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink0'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet0'>
        <pre class='snippet java' id='java0'>
import edu.umd.cs.piccolo.PCanvas;
import edu.umd.cs.piccolo.nodes.PText;
import edu.umd.cs.piccolox.PFrame;

// The PFrame class is a utility class that creates a new java window
// and adds a PCanvas to it. You can override the initialize method and
// start building your interface there.
public class Piccolo2DExample extends PFrame {
        public void initialize() {
                PNode aNode = new PText("Hello World!");                

                // Add the node to the canvas layer so that it
                // will be displayed on the screen.
                getCanvas().getLayer().addChild(aNode);
        }

        public static void main(String[] args) {
                new Piccolo2DExample();
        }
}
</pre>
        <pre class='snippet csharp' id='csharp0'>
using UMD.HCIL.Piccolo2D;
using UMD.HCIL.Piccolo2D.Nodes;
using UMD.HCIL.Piccolo2DX;

// The PForm class is a utility class that creates a new window
// and adds a PCanvas to it. You can override the Initialize method and
// start building your interface there.
public class Piccolo2DExample : PForm {
        public override void Initialize() {
                PText text = new PText("Hello World");

                // Add the node to the canvas layer so that it
                // will be displayed on the screen.
                Canvas.Layer.AddChild(text);
        }

        [STAThread]
        static void Main() {
                Application.Run(new Piccolo2DExample());
        }
}
</pre>
      </div>
      <p>
        <em>Note:</em> For simplicity, the C# example does not include the initialization code
        inserted by Visual Studio.
      </p>
      <p>
        This creates the default zooming interface. A new text node is added to the surface, and
        event handlers for zooming and panning are automatically installed by the
        <code>PCanvas</code>.
      </p>
      <ul>
        <li>
          To quickly get started using Piccolo2D, see <a href='#Usage_Patterns'>Usage Patterns for
          Piccolo2D</a>
        </li>
        <li>
          To learn more about the Piccolo2D implementation, see
          <a href='#implementation_patterns'>Implementation Patterns for Piccolo2D</a>
        </li>
        <li>
          To learn more about common ZUI design patterns, see <a href='#interface_patterns'>Design
          Patterns for ZUI Interfaces</a>
        </li>
      </ul>
      <h2 id='Usage_Patterns'>
        Usage Patterns for Piccolo2D
      </h2>
      <p>
        The Piccolo2D usage patterns are designed to get you up and running with Piccolo2D as
        quickly as possible. They provide quick "cookbook" explanations of the major things that
        can be done with Piccolo2D. To gain a better understanding of the Piccolo2D implementation
        and of its runtime behavior is see <a href='#implementation_patterns'>Implementation
        Patterns for Piccolo2D</a>.
      </p>
      <ul>
        <li>
          To create nodes see, <a href='#creating_nodes'>Creating Nodes</a>
        </li>
        <li>
          To create user interactions, see <a href='#User_Interaction'>Adding User Interaction</a>
        </li>
        <li>
          To create animations, see <a href='#Activities'>Activities</a>
        </li>
      </ul>
      <h3 id='Building_Piccolo2D'>
        Pattern 2: Building and Using Piccolo2D
      </h3>
      <p class='preamble'>
        To use <em>Piccolo2D.Java</em>, you will need to add the appropriate .jar files to your
        classpath, and to do that you need to know what each .jar file contains, and how to build
        the framework.
      </p>
      <p>
        Piccolo2D.Java comes with 4 .jar files:
      </p>
      <dl>
        <dt>
          piccolo.jar
        </dt>
        <dd>
          This .jar contains the Piccolo2D 2D zooming graphics framework.
        </dd>
        <dt>
          piccolox.jar
        </dt>
        <dd>
          This .jar contains the Piccolo2D extras, and it depends on piccolo.jar
        </dd>
        <dt>
          examples.jar
        </dt>
        <dd>
          This .jar contains simple examples of Piccolo2D, it depends on piccolo.jar and
          piccolox.jar.
        </dd>
        <dt>
          tests.jar
        </dt>
        <dd>
          This .jar contains unit tests for classes in the Piccolo2D framework, it depends on
          piccolo.jar and /lib/junit.jar
        </dd>
      </dl>
      <p>
        If you downloaded the compiled distribution of Piccolo2D.Java these .jar files are located
        for you in "piccolo2d/build/". If you didn't then you will need to build them yourself.
        This is done by typing 'build all' from within the piccolo2d/ folder.
      </p>
      <p>
        Piccolo2D.Java also comes with project files for the Eclipse IDE (www.eclipse.org), our
        favorite development environment for Piccolo2D.Java, and Java in general.
      </p>
      <p class='preamble'>
        To use <em>Piccolo2D.NET</em>, you will need to add references to the appropriate .dll
        files in your Visual Studio Project.
      </p>
      <p>
        Piccolo2D.NET comes with 2 .dll files and 2 .xml files:
      </p>
      <dl>
        <dt>
          UMD.HCIL.Piccolo2D.dll
        </dt>
        <dd>
          This .dll contains the Piccolo2D.NET 2D zooming graphics framework
        </dd>
        <dt>
          UMD.HCIL.Piccolo2DX.dll
        </dt>
        <dd>
          This .dll contains the Piccolo2D extras, and it depends on UMD.HCIL.Piccolo2D.dll.
        </dd>
        <dt>
          UMD.HCIL.Piccolo2D.xml
        </dt>
        <dd>
          This xml file is necessary to provide intellisense support for UMD.HCIL.Piccolo2D.dll,
          within the Visual Studio.NET IDE
        </dd>
        <dt>
          UMD.HCIL.Piccolo2DX.xml
        </dt>
        <dd>
          This xml file is necessary to provide intellisense support for UMD.HCIL.Piccolo2DX.dll,
          within the Visual Studio.NET IDE
        </dd>
      </dl>
      <p>
        You do not need to build either distribution of Piccolo2D.NET. The DLL distribution
        contains all four of these files at the top level. And, the source distribution contains
        these files in "Piccolo2D.NET/Bin/".
      </p>
      <p>
        However, if you modify the source code, then you will need to rebuild the framework.&nbsp;
        To do this, open "Piccolo2D.NET/Source/Piccolo2D.Net.sln" in Visual Studio.NET.&nbsp; Then,
        from the "Build" menu select "Rebuild Solution." The new .dll files will be located in
        "Piccolo2D.NET/Source/Piccolo2D/bin/Debug" and "Piccolo2D.NET/Source/Piccolo2DX/bin/Debug".
      </p>
      <p>
        <b>Note:</b> For more detailed instructions on setting up Piccolo2D, see the README file
        that comes with each distribution and the <a href='get-started.html'>Getting Started</a>
        tutorial.
      </p>
      <h3 id='Creating_Nodes'>
        Pattern 3: Creating Nodes
      </h3>
      <p class='preamble'>
        There are an infinite variety of nodes that can be included in a zoomable user interface.
        And, there are several ways to make new nodes for each application.
      </p>
      <dl>
        <dt>
          Use existing classes
        </dt>
        <dd>
          Piccolo2D is supplied with the default implementations for three kinds of visual nodes:
          <code>PText</code>, <code>PPath</code>, and <code>PImage</code>. These may be used
          &lsquo;as is' in a new application, which saves developers the time and effort required
          to create such elements themselves, but reduces the knowledge they have about how that
          figure is implemented.
        </dd>
        <dt>
          Subclass existing classes
        </dt>
        <dd>
          Often the default implementations of <code>PNodes</code> are &lsquo;almost but not quite'
          what is required for an interface. In such circumstances, it makes sense to customize the
          existing node to fit the needs of the interface. This saves time compared with starting
          from scratch and provides insight into the organization of that node but subclassing will
          increase the number of classes in the system and carries the responsibility of ensuring
          that the original intent of that inheritance hierarchy is maintained.&nbsp;
        </dd>
        <dt>
          Composition
        </dt>
        <dd>
          An alternative to subclassing, composition can be used in situations where the new
          functionality required can be created by arranging several preexisting nodes together. A
          text label could be defined as a rectangle (to define the border) with a text object
          inside. To facilitate this kind of creation any node may have other child nodes added to
          them. Adding a text node as a child of the rectangle node could create the text label
          mentioned above. Composition frees the developer from class details, allows reuse of
          existing tools and allows dynamic configuration (new arrangements of figures can be
          constructed while the program runs). But, composition doesn't provide as much freedom as
          subclassing (it can only compose what is available).&nbsp; And, because of its dynamic
          nature, it can be difficult to debug problems.
        </dd>
        <dt>
          Custom Node
        </dt>
        <dd>
          The ultimate amount of creative freedom comes from subclassing <code>PNode</code>
          directly. <code>PNode</code> already provides default behavior for all operations (it is
          a concrete class). So, it is fairly easy to subclass. Many subclasses will want to
          override a few key methods: <code>setBounds()</code>, <code>intersects()</code>, and
          <code>paint()</code> in Piccolo2D.Java and <code>SetBounds()</code>,
          <code>Intersects()</code> and <code>Paint()</code> in Piccolo2D.NET.
        </dd>
      </dl>
      <p>
        Each visual interface element in Piccolo2D is a subclass of <code>PNode</code>. Nodes can
        be used directly or customized by sub classing or composition.&nbsp;
      </p>
      <p>
        The following code defines a new simple (without a border) ellipse node.
      </p>
      <p class='toggle'>
        <a href='javascript:void(0)' class='toggle selected' id='jlink1'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0)' id='clink1'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet1'>
        <pre class='snippet java' id='java1'>
public class SimpleEllipseNode extends PNode {
        private Ellipse2D ellipse;

        // This nodes uses an internal Ellipse2D to define its shape.
        public Ellipse2D getEllipse() {
                if (ellipse == null) ellipse = new Ellipse2D.Double();
                return ellipse;
        }

        // This method is important to override so that the geometry of 
        // the ellipse stays consistent with the bounds geometry.
        public boolean setBounds(double x, double y, double width, double height) {
                if(super.setBounds(x, y, width, height)) {
                        ellipse.setFrame(x, y, width, height);
                        return true;
                }
                return false;
        }

        // Non rectangular subclasses need to override this method so
        // that they will be picked correctly and will receive the
        // correct mouse events.
        public boolean intersects(Rectangle2D aBounds) {
                return getEllipse().intersects(aBounds);
        }

        // Nodes that override the visual representation of their super
        // class need to override a paint method.
        public void paint(PPaintContext aPaintContext) {
                Graphics2D g2 = aPaintContext.getGraphics(); 
                g2.setPaint(getPaint());
                g2.fill(getEllipse());
        }
}
</pre>
        <pre class='snippet csharp' id='csharp1'>
public class SimpleEllipseNode : PNode {
        private GraphicsPath ellipse;

        // This node uses an internal GraphicsPath to define its shape.
        public GraphicsPath Ellipse {
                get {
                        if (ellipse == null) ellipse = new GraphicsPath();
                        return ellipse;
                }
        }

        // This method is important to override so that the geometry of 
        // the ellipse stays consistent with the bounds geometry.
        public override bool SetBounds(float x, float y, float width, float height) {
                if(base.SetBounds (x, y, width, height)) {
                        Ellipse.Reset();
                        Ellipse.AddEllipse(x, y, width, height);
                        return true;
                }
                return false;
        }

        // Non rectangular subclasses need to override this method so
        // that they will be picked correctly and will receive the
        // correct mouse events.
        public override bool Intersects(RectangleF bounds) {
                Region ellipseRegion = new Region(Ellipse);
                return ellipseRegion.IsVisible(bounds);
        }

        // Nodes that override the visual representation of their super
        // class need to override a paint method.
        protected override void Paint(PPaintContext paintContext) {
                Graphics g = paintContext.Graphics;
                if (Brush != null) {
                        g.FillPath(Brush, Ellipse);
                }
        }
}
</pre>
      </div>
      <ul>
        <li>
          To let the user change the attributes of a node, see <a href='#User_Interaction'>Adding
          user Interaction</a>
        </li>
        <li>
          To constrain the layout of a nodes children, see <a href='#Layout%20Constraints'>Layout
          Constraints</a>
        </li>
      </ul>
      <h3 id='Adding_User_Interaction'>
        Pattern 4: Adding User Interaction
      </h3>
      <p class='preamble'>
        Event listeners represent the modes of interaction between the user and the interface.
        Piccolo2D comes with event listeners that let the user zoom and pan their viewpoint, and
        drag nodes in the interface. An important part of designing an interface using Piccolo2D is
        to design the set of event listeners that will define the user experience.
      </p>
      <p>
        Once created an event listener must be registered with a node so that it can receive
        events. Many event handlers register with the camera node so that they get all events that
        come from the canvas associated with that camera.
      </p>
      <p>
        This example class creates an event listener that will create rectangle nodes on the
        canvas's layer when the user presses, drags, and then releases the mouse.
      </p>
      <p class='toggle'>
        <a href='javascript:void(0)' class='toggle selected' id='jlink2'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0)' id='clink2'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet2'>
        <pre class='snippet java' id='java2'>
// This event listener works by keeping track of the mouse press
// location and the current mouse drag location. It then sizes the new
// rectangle around those points. Note: The implementation of this event
// handler could be simplified by sub classing PDragSequenceEventHandler. 
public class RectangleCreationEventHandler extends PBasicInputEventHandler {
        // The rectangle that is currently getting created.
        protected PPath rectangle;
                        
        // The mouse press location for the current pressed, drag, release
        // sequence.
        protected Point2D pressPoint;
                        
        // The current drag location.
        protected Point2D dragPoint;
                
        public void mousePressed(PInputEvent e) {
                super.mousePressed(e);                  
                
                PLayer layer = ((PCanvas)(e.getComponent())).getLayer();

                // Initialize the locations.
                pressPoint = e.getPosition();
                dragPoint = pressPoint;                         
                                
                // create a new rectangle and add it to the canvas layer so
                // that we can see it.
                rectangle = new PPath();
                rectangle.setStroke(new BasicStroke(
                        (float)(1/ e.getCamera().getViewScale())));
                layer.addChild(rectangle);
                                
                // update the rectangle shape.
                updateRectangle();
        }
                        
        public void mouseDragged(PInputEvent e) {
                super.mouseDragged(e);
                // update the drag point location.
                dragPoint = e.getPosition();    
                                
                // update the rectangle shape.
                updateRectangle();
        }
                
        public void mouseReleased(PInputEvent e) {
                super.mouseReleased(e);
                // update the rectangle shape.
                updateRectangle();
                rectangle = null;
        }       
                
        public void updateRectangle() {
                // create a new bounds that contains both the press and
                // current drag point.
                PBounds b = new PBounds();
                b.add(pressPoint);
                b.add(dragPoint);
                
                // Set the rectangles bounds.
                rectangle.setPathTo(b);
        }
}
</pre>
        <pre class='snippet csharp' id='csharp2'>
// This event listener works by keeping track of the mouse press
// location and the current mouse drag location. It then sizes the new
// rectangle around those points. Note: The implementation of this event
// handler could be simplified by sub classing PDragSequenceEventHandler. 
public class RectangleCreationEventHandler : PBasicInputEventHandler {
        // The rectangle that is currently getting created.
        protected PPath rectangle;
                
        // The mouse press location for the current pressed, drag, release
        // sequence.
        protected PointF pressPoint;
                        
        // The current drag location.
        protected PointF dragPoint;

        public override void OnMouseDown(object sender, PInputEventArgs e) {
                base.OnMouseDown (sender, e);

                PLayer layer = e.Canvas.Layer;

                // Initialize the locations.
                pressPoint = e.Position;
                dragPoint = pressPoint;                         
                                
                // Create a new rectangle and add it to the canvas layer so
                // that we can see it.
                rectangle = new PPath();
                rectangle.Pen = new Pen(Brushes.Black,
                        (float)(1/ e.Camera.ViewScale));
                layer.AddChild(rectangle);
                                
                // update the rectangle shape.
                UpdateRectangle();
        }

        public override void OnMouseDrag(object sender, PInputEventArgs e) {
                base.OnMouseDrag (sender, e);
                // Update the drag point location.
                dragPoint = e.Position;
                                
                // Update the rectangle shape.
                UpdateRectangle();
        }

        public override void OnMouseUp(object sender, PInputEventArgs e) {
                base.OnMouseUp (sender, e);
                // Update the rectangle shape.
                UpdateRectangle();
                rectangle = null;
        }

        public void UpdateRectangle() {
                // Create a new bounds that contains both the press and
                // current drag point.
                RectangleF r = RectangleF.Empty;
                r = PUtil.AddPointToRect(r, pressPoint);
                r = PUtil.AddPointToRect(r, dragPoint);
                                
                // Set the rectangles bounds.
                rectangle.PathReference.Reset();
                rectangle.AddRectangle(r.X, r.Y, r.Width, r.Height);
        }
}        
</pre>
      </div>
      <p>
        The code to register this event listener with the canvas would look like this:
      </p>
      <p class='toggle'>
        <a href='javascript:void(0)' class='toggle selected' id='jlink3'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0)' id='clink3'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet3'>
        <pre class='snippet java' id='java3'>
getCanvas().addInputEventListener(new RectangleCreationEventHandler());
</pre>
        <pre class='snippet csharp' id='csharp3'>
Canvas.AddInputEventListener(new RectangleCreationEventHandler());
</pre>
      </div>
      <p>
        Note that this event handler reacts to the same events that the zoom and pan event handlers
        react to. If they are all active on the canvas at the same time undesired behavior would
        occur. Often you will want to remove the default pan and zoom event handlers associated
        with the <code>PCanvas</code>, this can be done as follows:
      </p>
      <p class='toggle'>
        <a href='javascript:void(0)' class='toggle selected' id='jlink4'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0)' id='clink4'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet4'>
        <pre class='snippet java' id='java4'>
getCanvas().removeInputEventListener(getCanvas().getZoomEventHandler());
getCanvas().removeInputEventListener(getCanvas().getPanEventHandler());
</pre>
        <pre class='snippet csharp' id='csharp4'>
Canvas.RemoveInputEventListener(Canvas.ZoomEventHandler);
Canvas.RemoveInputEventListener(Canvas.PanEventHandler);
</pre>
      </div>
      <p>
        In Piccolo2D.NET you can also use the following shortcut:
      </p>
      <p class='toggle selected'>
        C#
      </p>
      <pre class='snippet'>
Canvas.ZoomEventHandler = null;
Canvas.PanEventHandler = null;
</pre>
      <p>
        A general problem when defining global event handlers is making sure that they do not
        conflict. The Java <code>PInputEventFilter</code> class and the C#
        <code>PInputEventListener.DoesAcceptEvent()</code> method can help in this regard.
      </p>
      <p>
        In Piccolo2D.NET there is another way to handle basic input events.&nbsp; You can connect
        an event handler method directly to a node in the same way that .NET event handlers can be
        connected to a control.&nbsp; This allows you to define your event handlers in style
        consistent with .NET events.&nbsp; For example, the following code prints a message every
        time the user clicks the green node:
      </p>
      <p class='toggle selected'>
        C#
      </p>
      <pre class='snippet' id='o_csharp1'>
public override void Initialize() {
        PNode aNode = new PNode();
        aNode.SetBounds(0,0, 100, 100);
        aNode.Brush = Brushes.Green;
        Canvas.Layer.AddChild(aNode);

        aNode.MouseDown += new PInputEventHandler(aNode_MouseDown);
}

protected void aNode_MouseDown(object sender, PInputEventArgs e) {
        System.Console.WriteLine("Clicked aNode!");
}
</pre>
      <p>
        For more information about the tradeoffs of each of these approaches see the
        <a href='get-started.html'>Defining User Interaction</a> tutorial on the
        <a href='get-started.html'>Getting Started</a> page.
      </p>
      <ul>
        <li>
          To learn more about coordinate systems, see <a href='#Coordinate_Systems'>Coordinate
          Systems</a>
        </li>
        <li>
          To learn more about event dispatch, see <a href='#Dispatching_Events'>Dispatching
          Events</a>
        </li>
      </ul>
      <h3 id='Layout_Constraints'>
        Pattern 5: Layout Constraints
      </h3>
      <p class='preamble'>
        Often an interface has constraints that must be maintained between a node and its children.
        For example a node may want to always make its children line up in a row or a node may wish
        to expand its base size to always fully contain the bounds of its children.
      </p>
      <p>
        The <code>PNode</code> class does no automatic layout of its own, but it provides methods
        that subclasses can override to perform layout in the appropriate place during the layout
        process.. The following is a simple layout node that overrides and lays its children out in
        a horizontal row.
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink5'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink5'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet5'>
        <pre class='snippet java' id='java5'>
PNode layoutNode extends PNode {
        public void layoutChildren() {
                double xOffset = 0;
                double yOffset = 0;
                        
                Iterator i = getChildrenIterator();
                while (i.hasNext()) {
                        PNode each = (PNode) i.next();
                        each.setOffset(xOffset - each.getX(), yOffset);
                        xOffset += each.getFullBoundsReference().getWidth();
                }
        }
}
</pre>
        <pre class='snippet csharp' id='csharp5'>
public class LayoutNode : PNode {
        public override void LayoutChildren() {
                float xOffset = 0;
                float yOffset = 0;
                
                PNodeList children = this.ChildrenReference;
                foreach (PNode each in children) {
                        each.Offset = new PointF(xOffset - each.X, yOffset);
                        xOffset += each.FullBounds.Width;
                }
        }
}

</pre>
      </div>This layout code will automatically be called when the bounds of the layout node
      change, or when the fullBounds of any of the layout node's children change. 
      <ul>
        <li>
          For more information on the layout process, see <a href='#Validating%20Bounds'>Validating
          Bounds</a>
        </li>
        <li>
          For more information on the "full" term used in fullBounds, see
          <a href='#Full%20Terminology'>Full Terminology</a>
        </li>
      </ul>
      <h3 id='Activities'>
        Pattern 6: Activities
      </h3>
      <p class='preamble'>
        Event handlers let an interface react to a user. Actives are used to give the interface a
        life of its own through the use of animation and other "scheduled" behaviors.
      </p>
      <p>
        Activities control some time-dependent aspect of the Piccolo2D system, usually some part of
        a node. This behavior may be of fixed duration or may continue until some termination
        condition is met (or perhaps forever). Activities of fixed duration may be defined to
        consume a fixed amount of time, independent of the frame rate.
      </p>
      <p>
        This method sets up a flash activity that flashes the given node's color from red to green
        for 5 seconds.
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink6'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink6'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet6'>
        <pre class='snippet java' id='java6'>
public void flashNode(final PNode aNode) {
        PActivity flash = new PActivity(5000) {
                boolean fRed = true;
        
                protected void step(long time) {
                        super.step(time);               
                        if (fRed) {
                                aNode.setPaint(Color.red);
                        } else {
                                aNode.setPaint(Color.green);
                        }               
                        fRed = !fRed;
                }
        };
        // Must schedule the activity with the root for it to run.
        aNode.getRoot().addActivity(flash);
}
</pre>
        <pre class='snippet csharp' id='csharp6'>
public void flashNode(PNode aNode) {
        PActivity flash = new PActivity(5000);
        flash.ActivityStepped = new ActivitySteppedDelegate(ActivityStepped);

        // Must schedule the activity with the root for it to run.
        Canvas.Root.AddActivity(flash);
}

protected void ActivityStepped(PActivity activity) {
        if (fRed) {
                aNode.Brush = Brushes.Red;
        } else {
                aNode.Brush = Brushes.Green;
        }               
                        
        fRed = !fRed;
}
</pre>
      </div>
      <p>
        Activities are scheduled by the <code>PRoot</code> until they have completed. Note that for
        animation activities you can also use the convenience methods in <code>PNode</code>:
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink7'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink7'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet7'>
        <pre class='snippet java' id='java7'>
public PTransformActivity animateToPositionScaleRotation(double x, double y,
                double scale, double theta, long duration);
public PTransformActivity animateToTransform(AffineTransform aDestination,
                long duration);
</pre>
        <pre class='snippet csharp' id='csharp7'>
public virtual PTransformActivity AnimateToPositionScaleRotation(float x,
                float y, float scale, float theta, long duration);      
public virtual PTransformActivity AnimateToMatrix(PMatrix destMatrix,
                long duration);
</pre>
      </div>
      <p>
        Each activity has a start time and a duration, that together determine when an activity
        starts stepping and how long it continues to step. The Java
        <code>PActivity.startAfter()</code> and the C# <code>PActivity.StartAfter()</code> methods
        may be used to sequence an activity so that it starts right after another has stopped.
      </p>
      <ul>
        <li>
          To learn more about activities see, <a href='#Processing%20Activities'>Processing
          Activities</a>
        </li>
      </ul>
      <h3 id='SWT'>
        Pattern 7: Standard Widget Toolkit (SWT) connection
      </h3>
      <p class='preamble'>
        SWT is a new Java toolkit (similar to and replacing Swing) that comes out of the Eclipse
        IDE project. Piccolo2D.Java was originally designed to work with swing, but now has
        <em>preliminary</em> SWT support as well. You will most likely use SWT if you are writing
        Piccolo2D extensions to the Eclipse IDE. See
        <a href='http://www.eclipse.org'>www.eclipse.org</a> for more info on the Eclipse project.
      </p>
      <p>
        Again SWT support is not complete. We are interested in your feedback and hope it is of
        use, but we can not promise future updates. SWT support is provided in the extras package
        in <code>edu.umd.cs.piccolox.swt</code>, and you will find SWT examples in the examples
        package.&nbsp;Here is the code for SWT hello world:
      </p>
      <p class='toggle selected'>
        Java
      </p>
      <pre class='snippet' id='o_java0'>
public class SWTHelloWorld {

        public SWTHelloWorld() {
                super();
        }

        public static void main(String[] args) {
                Display display = new Display ();
                Shell shell = open(display);
                while (!shell.isDisposed()) {
                        if (!display.readAndDispatch()) display.sleep();
                }
                display.dispose();
        }
        
        public static Shell open(Display display) {
                final Shell shell = new Shell(display);
                shell.setLayout(new FillLayout());
                PSWTCanvas canvas = new PSWTCanvas(shell,0);
                
                PSWTText text = new PSWTText("Hello World");
                canvas.getLayer().addChild(text);
                
                shell.open();
                return shell;
        }
}
</pre>
      <h2 id='Implementation_Patterns_for_Piccolo2D'>
        Implementation Patterns for Piccolo2D
      </h2>
      <p>
        The Piccolo2D implementation patterns are designed to give a general understanding of how
        Piccolo2D is implemented and what its runtime behaviors are. This is opposed to the
        patterns in <a href='#Usage_Patterns'>Usage Patterns For Piccolo2D</a> that are designed to
        get you using the framework as quickly as possible.
      </p>
      <h3 id='Piccolo2D_Framework_Design'>
        Pattern 8: Piccolo2D Framework Design
      </h3>
      <p class='preamble'>
        You should be familiar with the basic concepts of the Piccolo2D framework design and how
        they relate to each other to effectively use Piccolo2D.
      </p>
      <p>
        Piccolo2D is a direct-manipulation graphics framework that supports constructing zoomable
        interfaces. The framework's design borrows heavily from the designs of both the Jazz and
        Morphic interface frameworks.
      </p>
      <p class='image'>
        <img src='../images/piccolo2d_hierachy.png' alt='Piccolo2D Class Hierarchy'
        style='background-color: white' /><br />
         Piccolo2D Class Hierarchy
      </p>
      <p>
        There are four main classes that define the framework's core:
      </p>
      <ol>
        <li>
          <code>PNode</code> (anything that is visible and gets events)
        </li>
        <li>
          <code>PCamera</code> (a node that looks at other layer nodes, and applies a view
          transform)
        </li>
        <li>
          <code>PLayer</code> (a node that can be looked at by a camera)
        </li>
        <li>
          <code>PRoot</code> (the root of the Piccolo2D display tree)
        </li>
        <li>
          <code>PCanvas</code> (the host component that lets <code>PNodes</code> exist in a Java
          Swing or .NET Windows application. Each <code>PCanvas</code> is associated with a
          <code>PCamera</code>. But all cameras are not necessarily directly associated with a
          <code>PCanvas</code>, internal cameras for example are not.)
        </li>
      </ol>
      <p class='image'>
        <img src='../images/piccolo2d_runtime.png' alt='Piccolo2D Runtime Structure' /><br />
         Piccolo2D Runtime Structure
      </p>
      <p>
        At runtime these classes form a tree-like structure with the <code>PRoot</code> situated at
        the top. Each <code>PCamera</code> is normally linked with at least one <code>PLayer</code>
        that it looks at through it's view transform. If a camera is associated with a canvas then
        that camera's view is displayed on the canvas, and input events from the canvas enter the
        Piccolo2D scene graph at that camera's point in the hierarchy.
      </p>
      <h3>
        PNode
      </h3>
      <p>
        Nodes are the central design concept in Piccolo2D. Any object that wants to paint itself on
        the screen should inherit from the node class. In addition to painting on the screen all
        nodes may have other "child" nodes added to them. Visual structures are build up by
        grouping and sub grouping collections of nodes.
      </p>
      <p>
        Each node also has its own affine transform that is applied before the node is drawn to the
        screen. This transform can be modified to scale and translate the node. The transform exits
        directly above the node, but below the node's parent.&nbsp; Thus, translating it will
        translate the node (and all its descendents) but will not translate the node's parent.
      </p>
      <h3>
        PCamera
      </h3>
      <p>
        Cameras are nodes that have an additional view transform and a collection of layers in
        addition to the collection of children that they inherit from <code>PNode</code>. The view
        transform is applied before drawing or picking the layers, but not when drawing or picking
        the camera's children. Cameras may (an internal camera might not) also reference a
        <code>PCanvas</code>, and forward repaint events to that canvas. The canvas would then
        later ask the camera to draw the damaged region on its surface.
      </p>
      <h3>
        PLayer
      </h3>
      <p>
        Layer nodes are nodes that can be viewed by a one or more cameras. They maintain a list of
        the cameras that are viewing them, and notify these cameras when they are repainted.
      </p>
      <h3>
        PRoot
      </h3>
      <p>
        The <code>PRoot</code> serves as the topmost node in the Piccolo2D runtime structure; all
        other nodes are its direct children or descendents of its children. The
        <code>PCanvas</code> communicates with the root node to manage screen updates and to
        dispatch events to its children.
      </p>
      <h3>
        PCanvas
      </h3>
      <p>
        The <code>PCanvas</code> is a <code>JComponent</code> in Piccolo2D.Java and a
        <code>Control</code> in Piccolo2D.NET. Thus, it is used to view a Piccolo2D scene graph in
        Java Swing and .NET Windows applications respectively. The <code>PCanvas</code> views the
        scene graph through a <code>PCamera</code>. It forwards input events to that camera, and
        uses that camera to draw itself. Translating and scaling that camera's view transform is
        how panning and zooming are accomplished.
      </p>
      <h3 id='Full_Terminology'>
        Pattern 9: Full Terminology
      </h3>
      <p class='preamble'>
        Many of PNode's methods work on the composite structure (the node plus all its descendents)
        of the node. It is helpful to be able to easily distinguish these methods from ones that
        only work directly on the node and not on its children.
      </p>
      <p>
        Piccolo2D uses the term "full" to mean a node and its descendants with the node's transform
        applied. This helps distinguish between methods that work on a single node and those that
        work on a node together with all of its descendants with the node's transform applied. When
        traversing the node scene graph to paint or calculate bounds parent nodes generally call
        the "full" methods of their direct child nodes. For example:
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink8'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink8'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet8'>
        <pre class='snippet java' id='java8'>
// Returns the bounding box of the given node without the node's
// transform applied.
aNode.getBounds();

// Returns the bounds of the given node combined with the bounds of
// all of the descendants of that node after applying the node's
// transform. Descendants need not be contained in the bounds of
// their parent, so this full bounds value may be larger than the
// bounds, but it will never be smaller.
aNode.getFullBounds();

// This will paint just "aNode" and not any of its children. Normally this
// method is automatically called from the fullPaint method.
aNode.paint(aPaintContext);

// This will paint "aNode" together will all of that node's descendents.
aNode.fullPaint(aPaintContext);
</pre>
        <pre class='snippet csharp' id='csharp8'>
// Returns the bounding box of the given node without the node's
// transform applied.
aNode.Bounds;

// Returns the bounds of the given node combined with the bounds of
// all of the descendants of that node after applying the node's
// transform. Descendants need not be contained in the bounds of
// their parent, so this full bounds value may be larger than the
// bounds, but it will never be smaller.
aNode.FullBounds;

// This will paint just "aNode" and not any of its children. Normally this
// method is automatically called from the FullPaint method.
aNode.Paint(aPaintContext);

// This will paint "aNode" together will all of that node's descendents.
aNode.FullPaint(aPaintContext);
</pre>
      </div>
      <p>
        Subclasses should generally not override the "full" methods, since they are implemented in
        terms of other methods that can be overridden.
      </p>
      <h3 id='Coordinate_Systems'>
        Pattern 10: Coordinate Systems
      </h3>
      <p class='preamble'>
        Each node in Piccolo2D has its own transform that it uses to define its own coordinate
        system. It is essential that you understand coordinate systems, and how to convert from one
        coordinate system to another when designing a zoomable user interface.
      </p>
      <p>
        There may be thousands of different coordinate systems in a Piccolo2D interface (a
        different one for each node), but they can all be organized into three categories:
      </p>
      <dl>
        <dt>
          Local
        </dt>
        <dd>
          The local coordinate system is specific to a single node. This coordinate system exists
          directly below that nodes transform. The base bounds of a node are kept in this local
          coordinate system, while the fullBounds of a node are stored in the local coordinate
          system of the nodes parent. (This means that the full bounds of a node have been
          transformed up through the node's transform, but are still below the node's parent's
          transform).
        </dd>
        <dt>
          Global
        </dt>
        <dd>
          The global coordinate system exists above the root node's transform, but below the
          canvas's view transform. The global coordinate system serves as a common coordinate
          system that can be used as an intermediate when converting from the local coordinates of
          one node to that of another node.
        </dd>
        <dt>
          Canvas
        </dt>
        <dd>
          The canvas coordinate system is equal to the coordinate system of the
          <code>PCanvas</code>.
        </dd>
      </dl>
      <p>
        Piccolo2D provides methods that let you easily convert between different coordinate
        systems. The <code>PNode</code> class defines the methods:
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink9'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink9'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet9'>
        <ul class='snippet java' id='java9'>
          <li>
            localToGlobal() - Transform up from a node's local coordinate system into the global
            coordinates..
          </li>
          <li>
            globalToLocal() - Transform down from global coordinate system into a node's local
            coordinates.
          </li>
          <li>
            localToParent() - Transform up from a nodes local coordinate system into the node's
            parent's local coordinates.
          </li>
          <li>
            parentToLocal() - Transform down from a node's parent's local coordinate system into
            the node's local coordinates.
          </li>
        </ul>
        <ul class='snippet csharp' id='csharp9'>
          <li>
            LocalToGlobal() - Transform up from a node's local coordinate system into the global
            coordinates..
          </li>
          <li>
            GlobalToLocal() - Transform down from global coordinate system into a node's local
            coordinates.
          </li>
          <li>
            LocalToParent() - Transform up from a nodes local coordinate system into the node's
            parent's local coordinates.
          </li>
          <li>
            ParentToLocal() - Transform down from a node's parent's local coordinate system into
            the node's local coordinates.
          </li>
        </ul>
      </div>
      <p>
        Here is a typical example of how coordinate systems are used:
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink10'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink10'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet10'>
        <pre class='snippet java' id='java10'>
// This method connects the centers of two 
// rectangle nodes with a line node. If you know that two nodes
// exist in the same coordinate system then you don't need to make
// all these conversions. This example assumes the most general case where
// they all exist in different coordinate systems.
public void connectRectsWithLine(PPath rect1, PPath rect2,  PPath line) {

        // First get the center of each rectangle in the 
        // local coordinate system of each rectangle.
        Point2D r1c = rect1.getBounds().getCenter2D();          
        Point2D r2c = rect2.getBounds().getCenter2D();

        // Next convert that center point for each rectangle 
        // into global coordinate system.               
        rect1.localToGlobal(r1c);
        rect2.localToGlobal(r2c);

        // Now that the centers are in global coordinates they 
        // can be converted into the local coordinate system 
        // of the line node.            
        line.globalToLocal(r1c);
        line.globalToLocal(r2c);

        // Finish by setting the endpoints of the line to 
        // the center points of the rectangles, now that those
        // center points are in the local coordinate system of the line.
        line.setPathTo(new Line2D.Double(r1c, r2c));
}
</pre>
        <pre class='snippet csharp' id='csharp10'>
// This method connects the centers of two 
// rectangle nodes with a line node. If you know that two nodes
// exist in the same coordinate system then you don't need to make
// all these conversions. This example assumes the most general case where
// they all exist in different coordinate systems.
public void ConnectRectsWithLine(PPath rect1, PPath rect2,  PPath line) {

        // First get the center of each rectangle in the 
        // local coordinate system of each rectangle.
        PointF r1c = PUtil.CenterOfRectangle(rect1.Bounds);
        PointF r2c = PUtil.CenterOfRectangle(rect2.Bounds);

        // Next convert that center point for each rectangle 
        // into global coordinate system.
        r1c = rect1.LocalToGlobal(r1c);
        r2c = rect2.LocalToGlobal(r2c);

        // Now that the centers are in global coordinates they 
        // can be converted into the local coordinate system 
        // of the line node.            
        r1c = line.GlobalToLocal(r1c);
        r2c = line.GlobalToLocal(r2c);

        // Finish by setting the endpoints of the line to 
        // the center points of the rectangles, now that those
        // center points are in the local coordinate system of the line.
        line.Reset();
        line.AddLine(r1c.X, r1c.Y, r2c.X, r2c.Y);
}
</pre>
      </div>
      <h3 id='UI_Cycle'>
        Pattern 11: UI Cycle
      </h3>
      <p class='preamble'>
        The root node's UI Cycle is at the center of Piccolo2D's runtime behavior where it drives
        the processes for processing user input, activities, bounds management, and scheduling
        repaints.
      </p>
      <p>
        The <code>PRoot</code> class is responsible for running the UI Cycle. During each cycle it
        performs four actions:
      </p>
      <dl>
        <dt>
          Process Inputs
        </dt>
        <dd>
          Incoming input events from Swing or .NET are passed to the dispatch manager which will
          then send them to the appropriate <code>PInputEventListeners</code>.
        </dd>
        <dt>
          Process Activities
        </dt>
        <dd>
          All activities that are ready to run are given a chance to do so.
        </dd>
        <dt>
          Validate Bounds
        </dt>
        <dd>
          All invalidated bounds are updated, and bounds caches filled.
        </dd>
        <dt>
          Update Display
        </dt>
        <dd>
          Damage is collected for all areas of the screen that need to be repainted and is then
          sent to the Swing or .NET repaint manager.
        </dd>
      </dl>
      <p>
        The Piccolo2D UI loop is always driven from the event dispatch thread. A UI cycle is done
        for each new input event received by the canvas, and for each time the activity timer fires
        (to support animation).
      </p>
      <ul>
        <li>
          To learn more about Piccolo2D and threads, see <a href='#Threads'>Threads</a>
        </li>
        <li>
          To learn more about dispatching events, see <a href='#Dispatching%20Events'>Dispatching
          Events</a>
        </li>
        <li>
          To learn more about processing activities, see
          <a href='#Processing%20Activities'>Processing Activities</a>
        </li>
        <li>
          To learn more about the bounds validation, see <a href='#Validating%20Bounds'>Validating
          Bounds</a>
        </li>
        <li>
          To learn more about updating the display, see <a href='#updating_display'>Updating the
          Display</a>
        </li>
      </ul>
      <h3 id='Threads'>
        Pattern 12: Threads
      </h3>
      <p class='preamble'>
        Piccolo2D is not thread safe and should only be used by a single thread at a time, and that
        thread will almost always be the event dispatch thread.
      </p>
      <p>
        If you need to run a computation in another thread you will need to call special methods to
        connect the results of your computation back up to the event dispatch thread. In
        Piccolo2D.Java, use <code>SwingUtilities.invokeLater()</code> or
        <code>SwingUtilities.invokeAndWait()</code>. In Piccolo2D.NET, use
        <code>Control.BeginInvoke()</code> and <code>Control.Invoke()</code>.
      </p>
      <h3 id='Dispatching_Events'>
        Pattern 13: Dispatching Events
      </h3>
      <p class='preamble'>
        Event dispatch is the process through which Piccolo2D directs new events coming from the
        user to event handlers in the interface.
      </p>
      <p>
        All event dispatch is managed by the input manager (<code>PInputManager</code>). Events get
        to the dispatch manager by first coming off the Java or .NET event queue, next they are
        sent to the canvas (<code>PCanvas</code>) and the canvas forwards them to the input
        manager.
      </p>
      <p>
        The input manager then converts the incoming Java or .NET event to a Piccolo2D event.&nbsp;
        In Piccolo2D.Java, a <code>java.awt.InputEvent</code> is converted into a
        <code>PInputEvent</code>. In Piccolo2D.NET, a <code>System.EventArgs</code> is converted
        into a <code>PInputEventArgs</code>. Next the input manager sends the Piccolo2D event to
        the event listeners of the appropriate nodes. The dispatch manager maintains the following
        focus nodes:
      </p>
      <dl>
        <dt>
          Keyboard Focus
        </dt>
        <dd>
          The node that gets key events sent to it (Usually defined when the mouse is pressed)
        </dd>
        <dt>
          Mouse Over Focus
        </dt>
        <dd>
          The node that the mouse cursor is over. When a node first becomes the current mouse over
          node it is sent a mouse entered event, and when the mouse leaves it is sent a mouse
          exited event.
        </dd>
        <dt>
          Mouse Focus
        </dt>
        <dd>
          The mouse focus node is sent mouse pressed, dragged, and released events. When the mouse
          is pressed the dispatch manager gets the mouse over focus, and makes it the mouse focus
          node as well. This mouse focus node is sent all events from that mouse pressed, dragged,
          released sequence. After the release event arrives the dispatch manager sets the mouse
          focus back to null.
        </dd>
      </dl>
      <p>
        Events are dispatched up the <code>PPickPath</code> associated with a given focus node, so
        they percolate up the pick path until they are consumed or they reach the originating
        camera node.
      </p>
      <p>
        TIP: You can always get a reference to the dispatch manager from a
        <code>PInputEvent</code>, and ask it for the current focus nodes.&nbsp;
      </p>
      <h3 id='Processing_Activities'>
        Pattern 14: Processing Activities
      </h3>
      <p class='preamble'>
        All scheduled activities are given a chance to run during the UI Cycle.
      </p>
      <p>
        Activities are used to control some time dependent aspect of the Piccolo2D framework, for
        example they can be used to animate a node across the screen, or animate the camera's view
        transform to perform a zoom.
      </p>
      <h3 id='Validating_Bounds'>
        Pattern 15: Validating Bounds
      </h3>
      <p class='preamble'>
        When the geometry of a node changes its bounds caches need to be recomputed and the
        geometry of other related nodes may also be effected.
      </p>
      <p>
        Maintaining bounds caches and updating layouts can become very expensive when manipulating
        a large number of nodes. Because of this Piccolo2D uses a two stage incremental approach
        the layout management. The two stages consist of; a damage stage where damage is recorded
        in bit flags for each damaged node, and an incremental repair stage where the damage is
        repaired as is needed.
      </p>
      <p>
        The damage stage begins when some node geometry changes. When this happens the type of
        damage that occurred is recorded for each node. The are three kinds of damage that can
        occur:
      </p>
      <dl>
        <dt>
          bounds invalidated
        </dt>
        <dd>
          This damage is recorded whenever the bounds of a node change.
        </dd>
        <dt>
          full bounds invalidated
        </dt>
        <dd>
          This damage is recorded anytime the fullBoundsCache becomes invalid.
        </dd>
        <dt>
          child bounds invalidated
        </dt>
        <dd>
          This damage is recorded anytime the full bounds of any descendant node is invalidated.
        </dd>
      </dl>
      <p>
        Damage is repaired by <code>PNode's</code> validateFullBounds method at the end of the UI
        cycle. That method does the following things
      </p>
      <ol>
        <li>
          If the node's bounds have been invalidated, then validate them.
        </li>
        <li>
          If the node's child bounds invalidated flag is set then all of the nodes children a
          validated.
        </li>
        <li>
          Next layout the children. (by default, the layout method of <code>PNode</code> does
          nothing, but layout manager nodes would override it).
        </li>
        <li>
          If the nodes full bounds invalidated flag is set then: 
          <ol>
            <li>
              Record the node's old full bounds
            </li>
            <li>
              Compute the node's new full bounds
            </li>
            <li>
              If the node's full bounds have change make sure to invalidate the full bounds of the
              parent node.
            </li>
          </ol>
        </li>
        <li>
          The layout is now up to date, so clear the layout flags.
        </li>
      </ol>
      <h3 id='Updating_the_Display'>
        Pattern 16: Updating the Display
      </h3>
      <p class='preamble'>
        Piccolo2D should paint the screen only when needed, and it should be smart about only
        painting the portions of the screen that need to be painted.
      </p>
      <p>
        Display update in Piccolo2D is driven from the UI Cycle, and uses the same damage/repair
        design that Piccolo2D uses to validate bounds. When a node changes such that it needs to be
        repainted it invalidates its paint, and invalidates the child paint of all its ancestors.
        Later (at the end of the UI Cycle) screen damage is collected for all nodes with invalid
        paint.
      </p>
      <h1 id='Desing_Patterns_for_ZUI_Interfaces'>
        Design Patterns for ZUI Interfaces
      </h1>
      <p>
        This section contains a few basic patterns that occur frequently in ZUIs, and describes how
        they can be implemented with Piccolo2D. To learn more about using Piccolo2D see
        <a href='#Usage_Patterns'>Usage Patterns For Piccolo2D</a>, and to learn more about the
        Piccolo2D implementation see <a href='#implementation_patterns'>Implementation Patterns for
        Piccolo2D</a>.
      </p>
      <h3 id='Semantic_Zooming'>
        Pattern 17: Semantic Zooming
      </h3>
      <p class='preamble'>
        It is useful for an object to change its visual representation based on the scale that it
        is being viewed at. For example when a document is viewed from far away (at a small scale)
        in a ZUI it might be best to just show that documents title, but when the view is zoomed in
        all the documents content should become visible.
      </p>
      <p>
        To do semantic zooming in Piccolo2D you should override the appropriate paint method, and
        then choose how the node renders itself based on the scale stored in the paint context
        parameter. This example creates a new node that will paint its based bounds filed with a
        blue color when viewed at a scale that is less then one, and with an orange color when the
        scale is greater then one.
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink11'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink11'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet11'>
        <pre class='snippet java' id='java11'>
public class SemanticNode extends PNode {
        public void paint(PPaintContext aPaintContext) {
                double s = aPaintContext.getScale();
                Graphics2D g2 = aPaintContext.getGraphics();
                
                if (s &lt; 1) {
                        g2.setPaint(Color.blue);
                } else {
                        g2.setPaint(Color.orange);
                }
                
                g2.fill(getBoundsReference());
        }
}        
</pre>
        <pre class='snippet csharp' id='csharp11'>
public class SemanticNode : PNode {
        protected override void Paint(PPaintContext paintContext) {
                float s = paintContext.Scale;
                Graphics g = paintContext.Graphics;
                
                if (s &lt; 1) {
                        g.FillRectangle(Brushes.Blue, this.Bounds);
                } else {
                        g.FillRectangle(Brushes.Orange, this.Bounds);
                }
        }
}


</pre>
      </div>
      <h3 id='Sticky_Objects'>
        Pattern 18: Sticky Objects
      </h3>
      <p class='preamble'>
        It is useful for an object to "stick" to a camera, so that its position does not change
        even when the camera is zoomed and panned.
      </p>
      <p>
        To do this in Piccolo2D you should add the "sticky node" as a child of the camera. The
        camera's view transform is only applied to the layer nodes that it is viewing, not to its
        children. The children are drawn after (on top of) the layer nodes.
      </p>
      <p>
        This example creates a yellow rectangle with bounds handles and adds it to the camera as a
        sticky node.&nbsp; A standard rectangle is then added to the main layer.&nbsp; Zooming in
        and out will change the scale of the standard rectangle but not the sticky one.
      </p>
      <p class='toggle'>
        <a href='javascript:void(0);' class='toggle selected' id='jlink12'
        onmousedown='swapSections(&#39;csharp&#39;, &#39;java&#39;, &#39;clink&#39;, &#39;jlink&#39;);'>
        Java</a> | <a href='javascript:void(0);' id='clink12'
        onmousedown='swapSections(&#39;java&#39;, &#39;csharp&#39;, &#39;jlink&#39;, &#39;clink&#39;);'>
        C#</a>
      </p>
      <div class='snippet' id='snippet12'>
        <pre class='snippet java' id='java12'>
public void initialize() {      
        PPath sticky = PPath.createRectangle(0, 0, 50, 50);;
        sticky.setPaint(Color.YELLOW);
        sticky.setStroke(null);
        PBoundsHandle.addBoundsHandlesTo(sticky);
        getCanvas().getLayer().addChild(PPath.createRectangle(0, 0, 100, 80));
        getCanvas().getCamera().addChild(sticky);
}
</pre>
        <pre class='snippet csharp' id='csharp12'>
public override void Initialize() {
        PPath sticky = PPath.CreateRectangle(0, 0, 50, 50);;
        sticky.Brush = Brushes.Yellow;
        sticky.Pen = null;
        PBoundsHandle.AddBoundsHandlesTo(sticky);
        Canvas.Layer.AddChild(PPath.CreateRectangle(0, 0, 100, 80));
        Canvas.Camera.AddChild(sticky);
}       
</pre>
      </div>
    </div>
  </body>
</html>
