<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="112" tokens="585">
<file line="114" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/handles/PBoundsHandle.java"/>
<file line="114" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/PSWTBoundsHandle.java"/>
<codefragment>
<![CDATA[
					if (focus == null || focus.getPickedNode() != PSWTBoundsHandle.this) {
						aEvent.popCursor();
						cursorPushed = false;
					}
				}
			}
			public void mouseReleased(PInputEvent event) {
				if (cursorPushed) {
					event.popCursor();
					cursorPushed = false;
				}
			}
		};
		addInputEventListener(handleCursorHandler);
	}	

	/**
	 * Return the event handler that is responsible for setting the mouse
	 * cursor when it enters/exits this handle.
	 */
	public PBasicInputEventHandler getHandleCursorEventHandler() {
		return handleCursorHandler;
	}
	
	public void startHandleDrag(Point2D aLocalPoint, PInputEvent aEvent) {
		PBoundsLocator l = (PBoundsLocator) getLocator();
		l.getNode().startResizeBounds();
	}
	
	public void dragHandle(PDimension aLocalDimension, PInputEvent aEvent) {
	    PBoundsLocator l = (PBoundsLocator) getLocator();
				
		PNode n = l.getNode();
		PBounds b = n.getBounds();

		PNode parent = getParent();
		if (parent != n && parent instanceof PCamera) {
			((PCamera)parent).localToView(aLocalDimension);
		}

		localToGlobal(aLocalDimension);
		n.globalToLocal(aLocalDimension);
		
		double dx = aLocalDimension.getWidth();
		double dy = aLocalDimension.getHeight();
			
		switch (l.getSide()) {
			case SwingConstants.NORTH:
				b.setRect(b.x, b.y + dy, b.width, b.height - dy);
				break;
			
			case SwingConstants.SOUTH:
				b.setRect(b.x, b.y, b.width, b.height + dy);
				break;
			
			case SwingConstants.EAST:
				b.setRect(b.x, b.y, b.width + dx, b.height);
				break;
			
			case SwingConstants.WEST:
				b.setRect(b.x + dx, b.y, b.width - dx, b.height);
				break;
			
			case SwingConstants.NORTH_WEST:
				b.setRect(b.x + dx, b.y + dy, b.width - dx, b.height - dy);
				break;
			
			case SwingConstants.SOUTH_WEST:
				b.setRect(b.x + dx, b.y, b.width - dx, b.height + dy);
				break;
			
			case SwingConstants.NORTH_EAST:
				b.setRect(b.x, b.y + dy, b.width + dx, b.height - dy);
				break;
			
			case SwingConstants.SOUTH_EAST:
				b.setRect(b.x, b.y, b.width + dx, b.height + dy);
				break;
		}
		
		boolean flipX = false;
		boolean flipY = false;
		
		if (b.width < 0) {
			flipX = true;
			b.width = -b.width;
			b.x -= b.width;
		}
		
		if (b.height < 0) {
			flipY = true;
			b.height = -b.height;
			b.y -= b.height;
		}
		
		if (flipX || flipY) {
			flipSiblingBoundsHandles(flipX, flipY);
		}
		
		n.setBounds(b);
	}
	
	public void endHandleDrag(Point2D aLocalPoint, PInputEvent aEvent) {
		PBoundsLocator l = (PBoundsLocator) getLocator();
		l.getNode().endResizeBounds();
	}	
	
	public void flipSiblingBoundsHandles(boolean flipX, boolean flipY) {
		Iterator i = getParent().getChildrenIterator();
		while (i.hasNext()) {
			Object each = i.next();
			if (each instanceof PSWTBoundsHandle) {
]]>
</codefragment>
</duplication>
<duplication lines="72" tokens="581">
<file line="225" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/nodes/PStyledText.java"/>
<file line="303" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/nodes/PStyledText.java"/>
<codefragment>
<![CDATA[
			else {
				// Before each pass, start at the root
				curElement = rootElement;

				// Now we descend the hierarchy until we get to a leaf
				while (!curElement.isLeaf()) {
					curElement =
						curElement.getElement(curElement.getElementIndex(pos));
				}

				// These are the mandatory attributes
				
				AttributeSet attributes = curElement.getAttributes();
				Color foreground = style.getForeground(attributes);

				((AttributedString)stringContents.get(i)).addAttribute(
					TextAttribute.FOREGROUND,
					foreground,
					(int)Math.max(0,curElement.getStartOffset()-pEnd.runStart),
					(int)Math.min(pEnd.runLimit-pEnd.runStart,curElement.getEndOffset()-pEnd.runStart));			

				// These are the optional attributes

				Font font = (attributes.isDefined(StyleConstants.FontSize) || attributes.isDefined(StyleConstants.FontFamily)) ? style.getFont(attributes) : null;
				if (font == null) {
				    if (document instanceof DefaultStyledDocument) {
				        font = style.getFont(((DefaultStyledDocument)document).getCharacterElement(pos).getAttributes());
				        if (font == null) {
				            font = style.getFont(((DefaultStyledDocument)document).getParagraphElement(pos).getAttributes());
				        }
				        if (font == null) {
				            font = style.getFont(rootElement.getAttributes());
				        }
				    }
				    else {
				        font = style.getFont(rootElement.getAttributes());
				    }
				}					
				if (font != null) {
					((AttributedString)stringContents.get(i)).addAttribute(
							TextAttribute.FONT,
							font,
							(int)Math.max(0,curElement.getStartOffset()-pEnd.runStart),
							(int)Math.min(pEnd.runLimit-pEnd.runStart,curElement.getEndOffset()-pEnd.runStart));				    
				}				
				
				Color background = (attributes.isDefined(StyleConstants.Background)) ? style.getBackground(attributes) : null;
				if (background != null) {
					((AttributedString)stringContents.get(i)).addAttribute(
							TextAttribute.BACKGROUND,
							background,
							(int)Math.max(0,curElement.getStartOffset()-pEnd.runStart),
							(int)Math.min(pEnd.runLimit-pEnd.runStart,curElement.getEndOffset()-pEnd.runStart));					    
				}
				
				boolean underline = StyleConstants.isUnderline(attributes);
				if (underline) {
					((AttributedString)stringContents.get(i)).addAttribute(
						TextAttribute.UNDERLINE,
						Boolean.TRUE,
						(int)Math.max(0,curElement.getStartOffset()-pEnd.runStart),
						(int)Math.min(pEnd.runLimit-pEnd.runStart,curElement.getEndOffset()-pEnd.runStart));						
				}
					
				boolean strikethrough = StyleConstants.isStrikeThrough(attributes);
				if (strikethrough) {
					((AttributedString)stringContents.get(i)).addAttribute(
						TextAttribute.STRIKETHROUGH,
						Boolean.TRUE,
						(int)Math.max(0,curElement.getStartOffset()-pEnd.runStart),
						(int)Math.min(pEnd.runLimit-pEnd.runStart,curElement.getEndOffset()-pEnd.runStart));						
				}
]]>
</codefragment>
</duplication>
<duplication lines="118" tokens="482">
<file line="226" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/handles/PBoundsHandle.java"/>
<file line="226" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/PSWTBoundsHandle.java"/>
<codefragment>
<![CDATA[
				((PSWTBoundsHandle)each).flipHandleIfNeeded(flipX, flipY);
			}
		}
	}
	
	public void flipHandleIfNeeded(boolean flipX, boolean flipY) {		
		PBoundsLocator l = (PBoundsLocator) getLocator();	
		
		if (flipX || flipY) {		
			switch (l.getSide()) {
				case SwingConstants.NORTH: {
					if (flipY) {
						l.setSide(SwingConstants.SOUTH);
					}					
					break;
				}
				
				case SwingConstants.SOUTH: {
					if (flipY) {
						l.setSide(SwingConstants.NORTH);
					}					
					break;
				}
				
				case SwingConstants.EAST: {
					if (flipX) {
						l.setSide(SwingConstants.WEST);
					}					
					break;
				}
				
				case SwingConstants.WEST: {
					if (flipX) {
						l.setSide(SwingConstants.EAST);
					}					
					break;
				}
								
				case SwingConstants.NORTH_WEST: {
					if (flipX && flipY) {
						l.setSide(SwingConstants.SOUTH_EAST);
					} else if (flipX) {
						l.setSide(SwingConstants.NORTH_EAST);
					} else if (flipY) {
						l.setSide(SwingConstants.SOUTH_WEST);
					}
					
					break;
				}
				
				case SwingConstants.SOUTH_WEST: {
					if (flipX && flipY) {
						l.setSide(SwingConstants.NORTH_EAST);
					} else if (flipX) {
						l.setSide(SwingConstants.SOUTH_EAST);
					} else if (flipY) {
						l.setSide(SwingConstants.NORTH_WEST);
					}
					break;
				}
				
				case SwingConstants.NORTH_EAST: {
					if (flipX && flipY) {
						l.setSide(SwingConstants.SOUTH_WEST);
					} else if (flipX) {
						l.setSide(SwingConstants.NORTH_WEST);
					} else if (flipY) {
						l.setSide(SwingConstants.SOUTH_EAST);
					}
					break;
				}
				
				case SwingConstants.SOUTH_EAST: {
					if (flipX && flipY) {
						l.setSide(SwingConstants.NORTH_WEST);
					} else if (flipX) {
						l.setSide(SwingConstants.SOUTH_WEST);
					} else if (flipY) {
						l.setSide(SwingConstants.NORTH_EAST);
					}
					break;
				}
			}
		}
		
		// reset locator to update layout
		setLocator(l);
	}
	
	public Cursor getCursorFor(int side) {
		switch (side) {
			case SwingConstants.NORTH:
				return new Cursor(Cursor.N_RESIZE_CURSOR);

			case SwingConstants.SOUTH:
				return new Cursor(Cursor.S_RESIZE_CURSOR);
				
			case SwingConstants.EAST:
				return new Cursor(Cursor.E_RESIZE_CURSOR);
				
			case SwingConstants.WEST:
				return new Cursor(Cursor.W_RESIZE_CURSOR);
				
			case SwingConstants.NORTH_WEST:
				return new Cursor(Cursor.NW_RESIZE_CURSOR);
				
			case SwingConstants.SOUTH_WEST:
				return new Cursor(Cursor.SW_RESIZE_CURSOR);
				
			case SwingConstants.NORTH_EAST:
				return new Cursor(Cursor.NE_RESIZE_CURSOR);
				
			case SwingConstants.SOUTH_EAST:
				return new Cursor(Cursor.SE_RESIZE_CURSOR);
		}
		return null;
	}
}
]]>
</codefragment>
</duplication>
<duplication lines="123" tokens="344">
<file line="97" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/handles/PHandle.java"/>
<file line="96" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/PSWTHandle.java"/>
<codefragment>
<![CDATA[
				endHandleDrag(event.getPositionRelativeTo(PSWTHandle.this), event);
			}
		};

		addPropertyChangeListener(PNode.PROPERTY_TRANSFORM, new PropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent evt) {
				relocateHandle();
			}
		}); 	
		
		handleDragger.setEventFilter(new PInputEventFilter(InputEvent.BUTTON1_MASK));
		handleDragger.getEventFilter().setMarksAcceptedEventsAsHandled(true);
		handleDragger.getEventFilter().setAcceptsMouseEntered(false);
		handleDragger.getEventFilter().setAcceptsMouseExited(false);
		handleDragger.getEventFilter().setAcceptsMouseMoved(false); 	// no need for moved events for handle interaction, 
																		// so reject them so we don't consume them
		addInputEventListener(handleDragger);
	}
	
	/**
	 * Return the event handler that is responsible for the drag handle
	 * interaction.
	 */
	public PDragSequenceEventHandler getHandleDraggerHandler() {
		return handleDragger;
	}	

	/**
	 * Get the locator that this handle uses to position itself on its
	 * parent node.
	 */
	public PLocator getLocator() {
		return locator;
	}
	
	/**
	 * Set the locator that this handle uses to position itself on its
	 * parent node.
	 */
	public void setLocator(PLocator aLocator) {
		locator = aLocator;
		invalidatePaint();
		relocateHandle();
	}
	
	//****************************************************************
	// Handle Dragging - These are the methods the subclasses should
	// normally override to give a handle unique behavior.
	//****************************************************************
	
	/**
	 * Override this method to get notified when the handle starts to get dragged.
	 */
	public void startHandleDrag(Point2D aLocalPoint, PInputEvent aEvent) {
	}
	
	/**
	 * Override this method to get notified as the handle is dragged.
	 */
	public void dragHandle(PDimension aLocalDimension, PInputEvent aEvent) {
	}
	
	/**
	 * Override this method to get notified when the handle stops getting dragged.
	 */
	public void endHandleDrag(Point2D aLocalPoint, PInputEvent aEvent) {
	}
	
	//****************************************************************
	// Layout - When a handle's parent's layout changes the handle
	// invalidates its own layout and then repositions itself on its
	// parents bounds using its locator to determine that new
	// position.
	//****************************************************************
	
	public void setParent(PNode newParent) {
		super.setParent(newParent);
		relocateHandle();
	}
	
	public void parentBoundsChanged() {
		relocateHandle();
	}
		
	/**
	 * Force this handle to relocate itself using its locator.
	 */
	public void relocateHandle() {
		if (locator != null) {
			PBounds b = getBoundsReference();
			Point2D aPoint = locator.locatePoint(null);
			
			if (locator instanceof PNodeLocator) {
				PNode located = ((PNodeLocator)locator).getNode();
				PNode parent = getParent();
				
				located.localToGlobal(aPoint);
				globalToLocal(aPoint);
				
				if (parent != located && parent instanceof PCamera) {
					((PCamera)parent).viewToLocal(aPoint);
				}
			}
			
			double newCenterX = aPoint.getX();
			double newCenterY = aPoint.getY();

			if (newCenterX != b.getCenterX() ||
				newCenterY != b.getCenterY()) {
				centerBoundsOnPoint(newCenterX, newCenterY);
			}
		}
	}
		
	//****************************************************************
	// Serialization
	//****************************************************************
	
	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
		in.defaultReadObject();
		installHandleEventHandlers();
	}
}
]]>
</codefragment>
</duplication>
<duplication lines="45" tokens="201">
<file line="44" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/handles/PStickyHandleManager.java"/>
<file line="44" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/PSWTStickyHandleManager.java"/>
<codefragment>
<![CDATA[
		PSWTBoundsHandle.addBoundsHandlesTo(this);
	}

	public void setCameraTarget(PCamera newCamera, PNode newTarget) {
		camera = newCamera;
		camera.addChild(this);
		target = newTarget;
	}
	
	public boolean setBounds(double x, double y, double width, double height) {
		PBounds b = new PBounds(x, y, width, height);
		camera.localToGlobal(b);
		camera.localToView(b);
		target.globalToLocal(b);
		target.setBounds(b);
		return super.setBounds(x, y, width, height);
	}
	
	protected boolean getBoundsVolatile() {
		return true;
	}

	public PBounds getBoundsReference() {
		PBounds targetBounds = target.getFullBounds();
		camera.viewToLocal(targetBounds);
		camera.globalToLocal(targetBounds);
		PBounds bounds = super.getBoundsReference();
		bounds.setRect(targetBounds);
		return super.getBoundsReference();
	}

	public void startResizeBounds() {
		super.startResizeBounds();
		target.startResizeBounds();
	}

	public void endResizeBounds() {
		super.endResizeBounds();
		target.endResizeBounds();
	}

	public boolean pickAfterChildren(PPickPath pickPath) {
		return false;
	}
}
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="144">
<file line="30" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/PSWTKeyEvent.java"/>
<file line="50" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/PSWTMouseEvent.java"/>
<codefragment>
<![CDATA[
	}
	
	public boolean isShiftDown() {
		return (swtEvent.stateMask & SWT.SHIFT) != 0;
	}

	public boolean isControlDown() {
		return (swtEvent.stateMask & SWT.CONTROL) != 0;
	}
	
	public boolean isAltDown() {
		return (swtEvent.stateMask & SWT.ALT) != 0;
	}
	
	public int getModifiers() {
		int modifiers = 0;
		
		if (swtEvent != null) {
			if ((swtEvent.stateMask & SWT.ALT) != 0) {
				modifiers = modifiers | InputEvent.ALT_MASK;	
			}
			if ((swtEvent.stateMask & SWT.CONTROL) != 0) {
				modifiers = modifiers | InputEvent.CTRL_MASK;
			}
			if ((swtEvent.stateMask & SWT.SHIFT) != 0) {
				modifiers = modifiers | InputEvent.SHIFT_MASK;	
			}
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="112">
<file line="548" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/SWTGraphics2D.java"/>
<file line="570" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/SWTGraphics2D.java"/>
<codefragment>
<![CDATA[
	public void fillRoundRect(double x, double y, double width, double height, double arcWidth, double arcHeight) {
		RECT.setRect(x,y,width,height);
		SWTShapeManager.transform(RECT,transform);		
		x = RECT.getX();
		y = RECT.getY();
		width = RECT.getWidth();
		height = RECT.getHeight();

		RECT.setRect(0,0,arcWidth,arcHeight);
		SWTShapeManager.transform(RECT,transform);
		arcWidth = RECT.getWidth();
		arcHeight = RECT.getHeight();

		gc.setLineWidth(getTransformedLineWidth());
		gc.fillRoundRectangle((int)(x+0.5),(int)(y+0.5),(int)(width+0.5),(int)(height+0.5),(int)(arcWidth+0.5),(int)(arcHeight+0.5));		
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="108">
<file line="97" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/handles/PBoundsHandle.java"/>
<file line="97" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/swt/PSWTBoundsHandle.java"/>
<codefragment>
<![CDATA[
	public PSWTBoundsHandle(PBoundsLocator aLocator) {
		super(aLocator);
	}
	
	protected void installHandleEventHandlers() {
		super.installHandleEventHandlers();
		handleCursorHandler = new PBasicInputEventHandler() {
			boolean cursorPushed = false;			
			public void mouseEntered(PInputEvent aEvent) {
				if (!cursorPushed) {
					aEvent.pushCursor(getCursorFor(((PBoundsLocator)getLocator()).getSide()));
					cursorPushed = true;
				}
			}
			public void mouseExited(PInputEvent aEvent) {
				PPickPath focus = aEvent.getInputManager().getMouseFocus();
				if (cursorPushed) {
					if (focus == null || focus.getPickedNode() != PSWTBoundsHandle.this) {
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="101">
<file line="458" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/event/PSelectionEventHandler.java"/>
<file line="485" path="/home/m/work/piccolo2d/piccolo2d.java/extras/src/main/java/edu/umd/cs/piccolox/event/PSelectionEventHandler.java"/>
<codefragment>
<![CDATA[
				unselectList.add(node);
			}
		}
		unselect(unselectList);
		

		// Then select the rest
		selectionEn = allItems.keySet().iterator();
		while (selectionEn.hasNext()) {
			PNode node = (PNode) selectionEn.next();
			if (!selection.containsKey(node) && !marqueeMap.containsKey(node) && isSelectable(node)) {
				marqueeMap.put(node,Boolean.TRUE);
			}
			else if (!isSelectable(node)) {
				selectionEn.remove();
			}
		}

		select(allItems);	
	}

	protected PNodeFilter createNodeFilter(PBounds bounds) {
]]>
</codefragment>
</duplication>
</pmd-cpd>